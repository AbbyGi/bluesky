********
Tutorial
********

Before You Begin
================

* You will need Python 3.5 or newer. Check your current version:

  .. code-block:: bash

    python --version

  If that version is less than 3.5, you can easily install a new version of
  Python into "virtual environment". It will not interfere with any existing
  Python software:

  .. code-block:: bash

    python -m venv ~/bluesky-tutorial
    source ~/bluesky-tutorial/bin/activate

  Alternatively, if you are a
  `conda <https://conda.io/docs/user-guide/install/download.html>`_ user,
  you can create a conda environment:

  .. code-block:: bash

    conda create -n bluesky-tutorial "python>=3.5"
    conda activate bluesky-tutorial

* Install the latest versions of bluesky and ophyd. And, optionally, ipython (a
  Python interpreter designed by scientists for scientists).

  .. code-block:: bash

     python -m pip install --upgrade bluesky ophyd ipython

* Start ``python`` or ``ipython``. Can you ``import bluesky``? If so, you are
  ready to go.

If you get lost or confused...
==============================

...then we want to know! We have a friendly
`chat channel <https://gitter.im/NSLS-II/DAMA>`_, or you can
`file a bug <https://github.com/NSLS-II/Bug-Reports/issues>`_ to let us know
where our documentation could be made more clear.

Devices
=======

In bluesky's view of the world, there are only three different kinds of devices
used in data acquisition.

* Some devices can be read. This includes simple points detectors that produce
  a single number and large CCD detectors that produce big arrays.
* Some devices can be both read and set. Setting a motor physically moves it to
  a new position. Setting a temperature controller impels it to gradually
  change its temperature. Setting the exposure time on some detector promptly
  updates its configuration.
* Some devices produce data at a rate too high to be read out in real time, and
  instead buffer their data temporarily on a device or separate software.

Bluesky interacts with all devices via a :doc:`specified interface <hardware>`.
Each device is represented by a Python object with certain methods and
attributes (with names like ``read`` and ``set``). Some of these methods are
asynchronous, such as ``set``, which allows for the concurrent movement of
multiple devices.

`Ophyd <https://nsls-ii.github.io/ophyd>`_, a Python library that was
developed in tandem with bluesky, implements this interface for devices that
speak `EPICS <http://www.aps.anl.gov/epics/>`_. But bluesky is not tied to
ophyd specifically: any Python object may be used, so long as it provides the
specified methods and attributes that bluesky expects. For example, a
separately-developed library has experimentally implemented the bluesky
interface for LabView.

For this tutorial, we will not assume that you have access to real detectors or
motors; instead we will use simulated hardware, which is also provided by
ophyd.

The RunEngine
=============

The RunEngine is the heart of bluesky, and we'll understand it better through
the examples that follow.

.. code-block:: python

    from bluesky import RunEngine

    RE = RunEngine({})

This RunEngine is ready to use --- but if you care about visualizing or saving
your data, there is more to do first....

Prepare Live Visualization
--------------------------

The RunEngine dispatches a live stream of metadata and data to one or more
consumers ("callbacks") for in-line data processing and visualization and
long-term storage. Examples might include a live-updating plot, a curve-fitting
algorithm, a database, or a file in your preferred format.

To start, let's use the all-purpose "Best-Effort Callback".

.. code-block:: python

    from bluesky.callbacks.best_effort import BestEffortCallback
    bec = BestEffortCallback()

    # Send all metadata/data captured to the BestEffortCallback.
    RE.subscribe(bec)

    # Make plots update live while scans run.
    from bluesky.utils import install_kicker
    install_kicker()

The Best-Effort Callback will receive the metadata/data in real time and
produce plots and text, doing its best to provide live feedback that strikes
the right balance between comprehensive and overwhelming. For more tailored
feeback, taking account of the details of the experiment, you may configure
custom callbacks.

Prepare Data Saving/Export
--------------------------

The `databroker <https://nsls-ii.github.io>`_, also co-developed with bluesky,
is an interface to long-term, searchable storage for metadata and data
generated by bluesky. Additionally (or *alternatively*, if you are not
interested in the databroker) the metadata and data can be written into the
file format of your choice. See :ref:`examples <export>`.

For this tutorial, we will spin up a databroker backed by a temporary database.

.. code-block:: python

    from databroker import Broker
    db = Broker.named('temp')

    # Insert all metadata/data captured into db.
    RE.subscribe(db.insert)

.. warning::

    **This example makes a temporary database. Do not use it for important
    data.** The data will become difficult to access once Python exits or the
    variable ``db`` is deleted. Running ``Broker.named('temp')`` a second time
    creates a fresh, separate temporary database.

The RunEngine can do a lot more than this, but let's hold that thought for
later in the tutorial (:ref:`things_the_run_engine_can_do_for_free`) and
take some data!

Common Experiments ("Plans")
============================

Read Some Detectors
-------------------

Let's trigger and read some detectors.
 
Bluesky calls this "counting" detectors (a term of art in the synchrotron
community, which is bluesky's hometown). Before we begin, we'll need some
simulated detectors from ophyd's module of simulated hardware.

.. code-block:: python

    from ophyd.sim import det1, det2

.. note::

    If we had access to *real* detector available via EPICS, we could instead
    do:

    .. code-block:: python

        from ophyd import EpicsSignal

        det = EpicsSignal('<SOME_PV>', name='det')

Using the RunEngine, configured in the previous section, "count" the detectors:

.. code-block:: python

    from bluesky.plans import count
    dets = [det1, det2]   # a list of any number of detectors
 
    RE(count(dets))

Scan Around a Peak
------------------

.. code-block:: python

    from ophyd.sim import det, motor
    from bluesky.plans import scan
    dets = [det]   # just one in this case, but it could be more than one

    RE(scan(dets, motor, -1, 1, 10))

To scan relative to the current position, use :func:`rel_scan`.

.. code-block:: python

    RE(scan(dets, motor, -1, 1, 10))

To scan points with some arbitrary spacing, use  :func:`list_scan`.

.. code-block:: python

    points = [1, 1, 2, 3, 5, 8, 13]

    RE(scan(dets, motor, points))

For a complete list of scan variations see ????

Scan Multiple Motors Together
-----------------------------

Scan Multiple Motors in a Grid
------------------------------

Compose a Series of Plans
=========================

condensed aside on yield from

some plan stubs

.. _things_the_run_engine_can_do_for_free:

Things the RunEngine Can Do For Free
====================================

Safe Error Handling
-------------------

User-Initiated Pause & Resume
-----------------------------

Automated Suspend & Resume
--------------------------

Progress Bar
------------

Optional but nice to have. Add one like so:

.. code-block:: python

    from bluesky.utils import ProgressBarManager
    
    RE.waiting_hook = ProgressBarManager()

For example, two motors ``phi`` and ``theat`` moving simultaneously make a
display like this:

.. code-block:: none

    phi    9%|███▊                                       | 0.09/1.0 [00:00<00:01,  1.36s/deg]
    theta100%|████████████████████████████████████████████| 1.0/1.0 [00:01<00:00,  1.12s/deg]

The display includes the name of the device(s) being waited on and, if
available:

* distance (or degrees, etc.) traveled so far
* total distance to be covered
* time elapsed
* estimated time remaining and the of progress (determined empirically)

See :doc:`progress-bar` for more details and configuration.

Supplemental Data
-----------------

Persistent Metadata
-------------------

Write Custom Plans
==================

Write Custom Callbacks
======================

Export
------

Visualization
-------------

Fitting
-------
