********
Tutorial
********

Before You Begin
================

* You will need Python 3.5 or newer. From a shell ("Terminal" on OSX,
  "Command Prompt" on Windows), check your current Python version.

  .. code-block:: bash

    python --version

  If that version is less than 3.5, you can easily install a new version of
  Python into "virtual environment". It will not interfere with any existing
  Python software:

  .. code-block:: bash

    python -m venv ~/bluesky-tutorial
    source ~/bluesky-tutorial/bin/activate

  Alternatively, if you are a
  `conda <https://conda.io/docs/user-guide/install/download.html>`_ user,
  you can create a conda environment:

  .. code-block:: bash

    conda create -n bluesky-tutorial "python>=3.5"
    conda activate bluesky-tutorial

* Install the latest versions of bluesky and ophyd. And, optionally, ipython (a
  Python interpreter designed by scientists for scientists).

  .. code-block:: bash

     python -m pip install --upgrade bluesky ophyd ipython

* Start ``ipython``. Can you ``import bluesky``? If so, you are ready to go.

If you get lost or confused...
==============================

...then we want to know! We have a friendly
`chat channel <https://gitter.im/NSLS-II/DAMA>`_, or you can
`file a bug <https://github.com/NSLS-II/Bug-Reports/issues>`_ to let us know
where our documentation could be made more clear.

.. _tutorial_run_engine_setup:

The RunEngine
=============

Bluesky encodes an experimental procedure as a *plan*, a sequence of
atomic instructions. The *RunEngine* is an interpreter for plans. It lets
us focus on the logic of our experimental procedure while it handles important
technical details for free: it communicates with hardware, monitors for
interruptions, organizes metadata and data, coordinates I/O, and ensures that
the hardware is left in a safe state at exit time.

.. note::

    If you are a visiting user at a facility that runs bluesky, you can skip
    this section and go straight to :ref:`common_experiments`. A RunEngine will
    have already been configured for you.

    You can type ``RE`` to check. You should get something like:

    .. ipython::
        :verbatim:

        In [1]: RE
        Out[1]: <bluesky.run_engine.RunEngine at 0x10fd1d978>

    If this gives you a ``NameError``, you'll need to finish this section.

Create a RunEngine:

.. code-block:: python

    from bluesky import RunEngine

    RE = RunEngine({})

.. ipython:: python
    :suppress:

    # for use in later demos
    from bluesky import RunEngine
    RE = RunEngine({})


This RunEngine is ready to use --- but if you care about visualizing or saving
your data, there is more to do first....

Prepare Live Visualization
--------------------------

The RunEngine dispatches a live stream of metadata and data to one or more
consumers ("callbacks") for in-line data processing and visualization and
long-term storage. Example consumers include a live-updating plot, a curve-fitting
algorithm, a database, a message queue, or a file in your preferred format.

To start, let's use the all-purpose "Best-Effort Callback".

.. code-block:: python

    from bluesky.callbacks.best_effort import BestEffortCallback
    bec = BestEffortCallback()

    # Send all metadata/data captured to the BestEffortCallback.
    RE.subscribe(bec)

    # Make plots update live while scans run.
    from bluesky.utils import install_kicker
    install_kicker()

.. ipython:: python
    :suppress:

    # for use in later demos
    from bluesky.callbacks.best_effort import BestEffortCallback
    bec = BestEffortCallback()
    RE.subscribe(bec)

The Best-Effort Callback will receive the metadata/data in real time and
produce plots and text, doing its best to provide live feedback that strikes
the right balance between "comprehensive" and "overwhelming." For more tailored
feeback, taking account of the details of the experiment, you may configure
custom callbacks.

Prepare Data Saving/Export
--------------------------

.. _databroker_setup:

The `databroker <https://nsls-ii.github.io>`_, also co-developed with bluesky,
is an interface to long-term, searchable storage for metadata and data
generated by bluesky. Additionally (or *alternatively*, if you are not
interested in the databroker) the metadata and data can be written into the
file format of your choice. See :ref:`examples <export>`.

For this tutorial, we will spin up a databroker backed by a temporary database.

.. code-block:: python

    from databroker import Broker
    db = Broker.named('temp')

    # Insert all metadata/data captured into db.
    RE.subscribe(db.insert)

.. ipython:: python
    :suppress:

    # for use in later demos
    from databroker import Broker
    db = Broker.named('temp')
    RE.subscribe(db.insert)

.. warning::

    **This example makes a temporary database. Do not use it for important
    data.** The data will become difficult to access once Python exits or the
    variable ``db`` is deleted. Running ``Broker.named('temp')`` a second time
    creates a fresh, separate temporary database.

Add a Progress Bar
------------------

Optionally, you can configure a progress bar.

.. code-block:: python

    from bluesky.utils import ProgressBarManager
    RE.waiting_hook = ProgressBarManager()

See :doc:`progress-bar` for more details and configuration.

Let's take some data!

.. _common_experiments:

Common Experiments ("Plans")
============================

Read Some Detectors
-------------------

Begin with a very simple experiment: trigger and read some detectors. Bluesky
calls this "counting", a term of art inherited from the spectroscopy
community.

For this tutorial, we will not assume that you have access to real detectors or
motors. In the examples that follow, we will use simulated hardware from
`ophyd <https://nsls-ii.github.io/ophyd>`_, a library developed in tandem with
bluesky. In a :ref:`later section <tutorial_device>` we will see what it looks
like to configure *real* hardware with ophyd.

.. code-block:: python

    from ophyd.sim import det1, det2  # two simulated detectors

Using the RunEngine, ``RE``, "count" the detectors:

.. code-block:: python

    from bluesky.plans import count
    dets = [det1, det2]   # a list of any number of detectors
 
    RE(count(dets))

A key feature of bluesky is that these detectors could simple photodiodes or
complex CCDs. All of those details are captured in the implementation of the
Device. From the point of view of bluesky, detectors are just Python objects
with certain methods.

See :func:`~bluesky.plans.count` for more options. You can also view this
documentation in IPython by typing ``count?``.

Try the following variations:

.. code-block:: python

    # five consecutive readings
    RE(count(dets, num=5))

    # five sequential readings separated by a 1-second delay
    RE(count(dets, num=5, delay=1))

    # a variable delay
    RE(count(dets, num=5, delay=[1, 2, 3, 4]))

    # Take readings forever, until interrupted (e.g., with Ctrl+C)
    RE(count(dets, num=None))
    # RunEngine is paused by Ctrl+C. It now needs to be 'stopped'.
    # See later section of tutorial for more on this....
    RE.stop()

The :func:`~bluesky.plans.count` function (more precisely, Python *generator
function*) is an example of a *plan*, a sequence of instructions to be consumed
encoding an experimental procedure. We'll get a better sense for why this
design is useful as we continue.

.. warning::

    Notice that typing that entering a plan by itself doesn't do anything:

    .. ipython:: python
        :suppress:

        from bluesky.plans import count
        from ophyd.sim import det
        dets = [det]

    .. ipython:: python

        count(dets, num=3)

    If we mean to *execute* the plan, we must use the RunEngine:

    .. ipython:: python

        RE(count(dets, num=3))

    If this strikes you as a bit onerous, we beg your patience. The RunEngine
    does a lot of work for free, and it more than earns its keep. Stick with
    us....

Scan
----

Use :func:`~bluesky.plans.scan` to scan ``motor`` from ``-1`` to ``1`` in ten
equally-spaced steps, wait for it to arrive at each step, and then trigger and
read some detector, ``det``.

.. code-block:: python

    from ophyd.sim import det, motor
    from bluesky.plans import scan
    dets = [det]   # just one in this case, but it could be more than one

    RE(scan(dets, motor, -1, 1, 10))

A key feature of bluesky is that ``motor`` may be any "movable" devices,
including a temperature controller, a sample changer, or some pseudo-axis. From
the point of view of bluesky and the RunEngine, all of these are just objects
in Python with certain methods.

Use :func:`~bluesky.plans.rel_scan` to scan from ``-1`` to ``1`` *relative to
the current position*.

.. code-block:: python

    from bluesky.plans import rel_scan

    RE(rel_scan(dets, motor, -1, 1, 10))

Use :func:`~bluesky.plans.list_scan` to scan points with some arbitrary
spacing.

.. code-block:: python

    from bluesky.plans import list_scan

    points = [1, 1, 2, 3, 5, 8, 13]

    RE(list_scan(dets, motor, points))

For a complete list of scan variations see :doc:`plans`.

Scan Multiple Motors Together
-----------------------------

There are two different things we might mean by the phrase "scan multiple
motors 'together'". In this case we mean that we move N motors along a line in
M steps, such as moving X and Y motors along a diagonal. (In the other case, we
move N motors through an (M_1 x M_2 x ... x M_N) grid; that is addressed in the
next section.)

SPEC users may recognize this case as analogous to an "a2scan" or "d2scan", but
with an arbitrary number of dimensions, not just two.

We'll use the same plans that we used in the previous section. (If you already
imported them, there is no need to do so again.)

.. code-block:: python

    from bluesky.plans import scan, rel_scan

We'll use two new motors and a new detector that is coupled to them via
a simulation. It simulates a 2D Gaussian peak centered at ``(0, 0)``.
Again, we emphasize that these "motors" could be anything that can be "set"
(temperature controller, pseudo-axis, sample changer).

.. code-block:: python

    from ophyd.sim import det4, motor1, motor2
    dets = [det4]   # just one in this case, but it could be more than one

The plans :func:`~bluesky.plans.scan` and  :func:`~bluesky.plans.rel_scan`
accept multiple motors.

.. code-block:: python

    RE(scan(dets,
            motor1, -1, -1,  # scan motor1 from -1 to 1
            motor2, -10, 10,  # ...while scanning motor2 from -10 to 10
            11))  # ...both in 11 steps

The line breaks are intended to make the command easier to visually parse. They
are not technically meaningful; you may take them or leave them.

Demo:

.. ipython:: python
    :suppress:

    from bluesky import RunEngine
    from bluesky.plans import scan
    from ophyd.sim import det4, motor1, motor2
    dets = [det4]

.. ipython::
    :verbatim:
    
    # TODO Remove verbatim once `scan` support this usage.
    RE(scan(dets,
            motor1, 1, 5,  # scan motor1 from 1 to 5
            motor2, 10, 50,  # ...while scanning motor2 from 10 to 50
            11))  # ...both in 11 steps

This works for any number of motors, not just two. Try importing ``motor3``
from ``ophyd.sim`` and running a 3-motor scan.

Scan Multiple Motors in a Grid
------------------------------

In this case scan N motors through an N-dimensional rectangular grid. We'll use
the same simulated hardware as in the previous section:

.. code-block:: python

    from ophyd.sim import det4, motor1, motor2
    dets = [det4]   # just one in this case, but it could be more than one

We'll use a new plan, named :func:`~bluesky.plans.grid_scan`.

.. code-block:: python

    from bluesky.plans import grid_scan

Let's start with a 3x5 grid.

.. code-block:: python

    RE(grid_scan(dets,
                 motor1, -1, -1, 3,  # scan motor1 from -1 to 1 in 3 steps
                 motor2, -10, -10, 5, False))  # scan motor2 from -10 to 10 in 5

That final parameter --- ``False`` --- designates whether ``motor2`` should
"snake" back and forth along ``motor1``'s trajectory (``True``) or retread its
positions in the same direction each time (``False``), as illustrated.

.. plot::

    from bluesky.simulators import plot_raster_path
    from ophyd.sim import motor1, motor2, det
    from bluesky.plans import grid_scan
    import matplotlib.pyplot as plt

    true_plan = grid_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, True)
    false_plan = grid_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, False)

    fig, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
    plot_raster_path(true_plan, 'motor1', 'motor2', probe_size=.3, ax=ax1)
    plot_raster_path(false_plan, 'motor1', 'motor2', probe_size=.3, ax=ax2)
    ax1.set_title('True')
    ax2.set_title('False')
    ax1.set_xlim(-6, 6)
    ax2.set_xlim(-6, 6)

The order of the motors controls how the grid is traversed. The "slowest" axis
comes first. Numpy users will appreciate that this is consistent with numpy's
convention for indexing multidimensional arrays. Since the first (slowest) axis
is only traversed once, it does not need a "snake" option. All subsequent
axes do. Example:

.. code-block:: python

    from ophyd.sim import motor3

    # a 3 x 5 x 2 grid
    RE(grid_scan(dets,
                 motor1, -1, 1, 3,  # no snake parameter
                 motor2, -10, -10, 5, False),
                 motor3, , -2, 2, 5, False))

For plans incorporating adaptive logic, more specialized trajectories such as
spirals, and more, see :doc:`plans`.

Aside: Access Saved Data
========================

At this point it is natural to wonder, "OK, how do I access my saved data?"
From the point of view of *bluesky*, that's really not bluesky's concern, but
it's a reasonable question, so we'll address a typical scenario.

.. note::

    This section presumes that you are using the databroker. (We configured
    one in :ref:`an earlier section of this tutorial <databroker_setup>`.)
    You don't have to use the databroker to use bluesky; it's just
    one convenient way to capture the metadata and data generated by the
    RunEngine.

Very briefly, you can access saved data by referring to a dataset (a "run") by
its unique ID, which is returned by the RunEngine at collection time.

.. ipython:: python

    from bluesky.plans import count
    from ophyd.sim import det
    uid, = RE(count([det], num=3))
    header = db[uid]

Alternatively, perhaps more conveniently, you can access it by recently:

.. ipython:: python

    header = db[-1]  # meaning '1 run ago', i.e. the most recent run

.. note::

    We assumed above that the plan generated one "run" (dataset), which is
    typical for simple plans like :func:`~bluesky.plans.count`. In the
    *general* case, a plan can generate multiple runs, returning multiple uids,
    which in turn causes ``db`` to return a list of headers, not just one.

    .. code-block:: python

        uids = RE(some__plan(...))
        headers = db[uids]  # list of Headers

Most of the useful metadata is in this dictionary:

.. ipython:: python

    header.start

And the ("primary") stream of data is accessible like so:

.. ipython:: python

    header.table()  # return a table (a pandas.DataFrame)

From here we refer to the
`databroker tutorial <https://nsls-ii.github.io/databroker/tutorial.html>`_.

Simple Customization
====================

Save Some Typing with 'Partial'
-------------------------------

Suppose we nearly always use the same detector(s) and we tire of typing out
``count(dets)``. We can write a custom variant of :func:`~bluesky.plans.count`
using a built-in function provided by Python itself, :func:`functools.partial`.

.. code-block:: python

    from functools import partial
    from bluesky.plans import count
    from ophyd.sim import det

    dets = [det]

    my_count = partial(count, dets)
    RE(my_count())  # equivalent to RE(count(dets))

    # Additional arguments to my_count() are passed through to count().
    RE(my_count(num=3, delay=1))

Plans in Series
---------------

A custom plan can dispatch out to other plans using the Python syntax
``yield from``. (See :ref:`appendix <yield_from_primer>` if you want to know
why.) Examples:

.. code-block:: python

    from bluesky.plans import scan

    def coarse_and_fine(detectors, start, stop):
        "Scan from 'start' to 'stop' in 10 steps and then again in 100 steps."
        yield from scan(detectors, start, stop, 10)
        yield from scan(detectors, start, stop, 100)

    RE(coarse_and_fine(dets, -1, 1))

All of the plans introduced thus far, which we imported from
:mod:`bluesky.plans`, generate data sets ("runs"). Plans in the
:mod:`bluesky.plan_stubs` module do smaller operations. They can be used alone
or combined to build custom plans.

The :func:`~bluesky.plan_stubs.mv` plan moves one or more devices and waits for
them all to arrive.

.. code-block:: python

    from bluesky.plan_stubs import mv
    from ophyd.sim import motor1, motor2

    # Move motor1 to 1 and motor2 to 10, simultaneously. Wait for both to arrive.
    RE(mv(motor1, 1, motor2, 10))

We can combine :func:`~bluesky.plan_stubs.mv` and :func:`~bluesky.plans.count`
into one plan like so:

.. code-block:: python

    def move_then_count():
        "Move motor1 and motor2 into position; then count det."
        yield from mv(motor1, 1, motor2, 10)
        yield from count(dets)

    RE(move_then_count())

It's very important to remember the ``yield from``. This plan does nothing at
all! (The plans inside it will be *defined* but never executed.)

.. code-block:: python

    # WRONG EXAMPLE!

    def oops():
        "Forgot 'yield from'!"
        mv(motor1, 1, motor2, 10)
        count(dets)

Much richer customization is possible, but we'll leave that for a
:ref:`a later section of this tutorial <tutorial_custom_plans>`. See also the
complete list of :ref:`plan stubs <stub_plans>`.

.. warning::

    **Never put ``RE(...)`` inside a loop or a function. You should always call
    it manually, and only once.**

    You might be tempted to write a script like this:

    .. code-block:: python

        from bluesky.plans import scan
        from ophyd.sim import motor, det

        # Don't do this!
        for j in [1, 2, 3]:
            print(j, 'steps')
            RE(scan([det], motor, 5, 10, j)))

    Or a function like this:

    .. code-block:: python

        # Don't do this!
        def bad_function():
            for j in [1, 2, 3]:
                print(j, 'steps')
                RE(scan([det], motor, 5, 10, j)))

    But, instead, you should do this:

    .. code-block:: python

        from bluesky.plans import scan
        from ophyd.sim import motor, det

        def good_plan():
            for j in [1, 2, 3]:
                print(j, 'steps')
                yield from scan([det], motor, 5, 10, j)

        RE(my_plan())

"Baseline" Readings (and other Supplemental Data)
=================================================

In addition to the detector(s) and motor(s) of primary interest during an
experiment, it is commonly useful to take a snapshot ("baseline reading") of
other hardware. This information is typically used to check consistency over
time. ("Is the temperature of the sample mount roughly the same as it was last
week?") Ideally, we'd like to *automatically* capture readings from these
devices during all future experiments without any extra thought or typing per
experiment. Bluesky provides a specific solution for this.

Configure
---------

.. note::

    If you are visiting user at a facility that runs bluesky, you may not need
    to do this configuration, and you can skip the next subsection just below
    --- :ref:`choose_baseline_devices`.

    You can type ``sd`` to check. You should get something like:

    .. ipython::
        :verbatim:

        In [1]: sd
        Out[1]: SupplementalData(baseline=[], monitors=[], flyers=[])

Before we begin, we have to do a little more RunEngine configuration, like what
we did in the :ref:`tutorial_run_engine_setup` section with ``RE.subscribe``.

.. code-block:: python

    from bluesky.preprocessors import SupplementalData

    sd = SupplementalData()
    RE.preprocessors.append(sd)

.. ipython:: python
    :suppress:

    from bluesky.preprocessors import SupplementalData
    sd = SupplementalData()
    RE.preprocessors.append(sd)

.. _choose_baseline_devices:

Choose "Baseline" Devices
-------------------------

We'll choose the detectors/motors that we want to be read automatically at the
beginning and end of each dataset ("run"). If you are using a shared
configuration, this also might already have been done, so you should check the
context of ``sd.baseline`` before altering it.

.. ipython:: python

    sd.baseline  # currently empty

Suppose that we want to take baseline readings from three detectors and two
motors. We'll import a handful of simulated devices for this purpose, put them
into a list, and assign ``sd.baseline``.

.. ipython:: python

    from ophyd.sim import det1, det2, det3, motor1, motor2
    sd.baseline = [det1, det2, det3, motor1, motor2]

Notice that we can put a mixture of detectors and motors in this list. It
doesn't matter to bluesky that some are movable and some are not because it's
just going to be *reading* them, and both detectors and motors can be read.

Use
---

Now we can just do a scan with the detector and motor of primary interest. The
RunEngine will automatically take baseline readings before and after each run.
Demo:

.. ipython:: python

    from ophyd.sim import det, motor
    from bluesky.plans import scan
    RE(scan([det], motor, -1, 1, 5))

We can clear or update the list of baseline detectors at any time.

.. ipython:: python

    sd.baseline = []

Access Baseline Data
--------------------

If you access the data from our baseline scan, you might think that the
baseline data is missing!

.. ipython:: python

    header = db[-1]
    header.table()

Looking at again the output when we executed this scan, notice these lines:

.. code-block:: none

    New stream: 'baseline'
    ...
    New stream: 'primary'

By default, ``header.table()`` gives us the "primary" data stream:

.. ipython:: python

    header.table('primary')  # same result as header.table()

We can access other streams by name.

.. ipython:: python

    header.table('baseline')

A list of the stream names in a given run is available as
``header.stream_names``. From here we refer to the
`databroker tutorial <https://nsls-ii.github.io/databroker/tutorial.html>`_.

Other Supplemental Data
-----------------------

Above, we used ``sd.baseline``. There is also ``sd.monitors`` for signals to
monitor asynchronously during a run and ``sd.flyers`` for devices to "fly-scan"
during a run. See :ref:`supplemental_data` for details.

Pause, Resume, Suspend
======================

Interactive Pause & Resume
--------------------------

Sometimes it is convenient to pause data collection, check on some things, and
then either resume from where you left off or quit. The RunEngine makes it
possible to do this cleanly and safely on *every* plan, including user-defined
ones, with no special effort by the user.

(Of course, experiments on systems that evolve with time can't be arbitrarily
paused and resumed. It's up to the user to know that and use this feature only
when applicable.)

Take this example, a step scan over ten points.

.. code-block:: python

    from ophyd.sim import det, motor
    from bluesky.plans import scan

    motor.delay = 1  # simulate slow motor movement
    RE(scan([det], motor, 1, 10, 10))

Demo:

.. ipython::
    :verbatim:

    In [1]: RE(scan([det], motor, 1, 10, 10))
    Transient Scan ID: 1     Time: 2018/02/12 12:40:36
    Persistent Unique Scan ID: 'c5db9bb4-fb7f-49f4-948b-72fb716d1f67'
    New stream: 'primary'
    +-----------+------------+------------+------------+
    |   seq_num |       time |      motor |        det |
    +-----------+------------+------------+------------+
    |         1 | 12:40:37.6 |      1.000 |      0.607 |
    |         2 | 12:40:38.7 |      2.000 |      0.135 |
    |         3 | 12:40:39.7 |      3.000 |      0.011 |

At this point we decide to hit **Ctrl+C** (SIGINT). The RunEngine will catch
this signal and react like so.

.. code-block:: none

    ^C
    A 'deferred pause' has been requested.The RunEngine will pause at the next
    checkpoint. To pause immediately, hit Ctrl+C again in the next 10 seconds.
    Deferred pause acknowledged. Continuing to checkpoint.
    <...a few seconds later...>
    |         4 | 12:40:40.7 |      4.000 |      0.000 |
    Pausing...

    ---------------------------------------------------------------------------
    RunEngineInterrupted                      Traceback (most recent call last)
    <ipython-input-14-826ee9dfb918> in <module>()
    ----> 1 RE(scan([det], motor, 1, 10, 10))
    <...snipped details...>

    RunEngineInterrupted:
    Your RunEngine is entering a paused state. These are your options for changing
    the state of the RunEngine:
    RE.resume()    Resume the plan.
    RE.abort()     Perform cleanup, then kill plan. Mark exit_stats='aborted'.
    RE.stop()      Perform cleanup, then kill plan. Mark exit_status='success'.
    RE.halt()      Emergency Stop: Do not perform cleanup --- just stop.

When it pauses, the RunEngine immediately tells all Devices that is has touched
to "stop". (Devices define what that means to them in their ``stop()`` method.)
Now, all the hardware should be safe. At our leisure, we may:

* pause to think
* investigate the state of our hardware, such as the detector's exposure time
* turn on more verbose logging  (see :doc:`debugging`)
* decide whether to stop here or resume

Suppose we decide to resume.

.. ipython::
    :verbatim:

    In [13]: RE.resume()
    |         5 | 12:40:50.1 |      5.000 |      0.000 |
    |         6 | 12:40:51.1 |      6.000 |      0.000 |
    |         7 | 12:40:52.1 |      7.000 |      0.000 |
    |         8 | 12:40:53.1 |      8.000 |      0.000 |
    |         9 | 12:40:54.1 |      9.000 |      0.000 |
    |        10 | 12:40:55.1 |     10.000 |      0.000 |
    +-----------+------------+------------+------------+
    generator scan ['c5db9bb4'] (scan num: 1)

If you read the demo above closely, you will see that the RunEngine didn't
pause immediately: it finished the current step of the scan first. Quoting an
excerpt from the demo above:


.. code-block:: none

    ^C
    A 'deferred pause' has been requested.The RunEngine will pause at the next
    checkpoint. To pause immediately, hit Ctrl+C again in the next 10 seconds.
    Deferred pause acknowledged. Continuing to checkpoint.
    <...a few seconds later...>
    |         4 | 12:40:40.7 |      4.000 |      0.000 |
    Pausing...

To pause immediately without waiting for the next "checkpoint" (e.g. the
beginning of the next step) hit Ctrl+C *twice*.

Quoting again from the demo, notice that ``RE.resume()`` was only one of our
options. If we decide not to continue we can quit in three different ways:

.. code-block:: none

    Your RunEngine is entering a paused state. These are your options for changing
    the state of the RunEngine:
    RE.resume()    Resume the plan.
    RE.abort()     Perform cleanup, then kill plan. Mark exit_stats='aborted'.
    RE.stop()      Perform cleanup, then kill plan. Mark exit_status='success'.
    RE.halt()      Emergency Stop: Do not perform cleanup --- just stop.

"Aborting" and "stopping" are almost the same thing: they just record different
metadata about why the experiment was ended. Both signal to the plan that it
should end early, but they still let it specify more instructions so that it
can "clean up." For example, a :func:`~bluesky.plans.rel_scan` moves the motor
back to its starting position before quitting.

In rare cases, if we are worried that the plan's cleanup procedure might be
dangerous, we can "halt". Halting circumvents the cleanup instructions.

Automated Suspend & Resume
--------------------------

The RunEngine can be configured in advance to *automatically* pause and resume
in response to external signals. To distinguish automatic pause/resume for
interactive, user-initiated pause and resume, we call this behavior
"suspending."

For details, see :ref:`suspenders`.

Metadata
========

If users pass extra keyword arguments to ``RE``, they are interpreted as
metadata

.. code-block:: python

    RE(count([det]), user='Dan', mood='skeptical')
    RE(count([det]), user='Dan', mood='optimistic')

and they can be use for searching later:

.. code-block:: python

    headers = db(user='Dan')
    headers = db(mood='skeptical')

Metadata can also be added *persistently* (i.e. applied to all future runs
until removed) by editing the dictionary ``RE.md``.

.. code-block:: python

    RE.md
    RE.md['user'] = 'Dan'

No need to specify user every time now....

.. code-block:: python

    RE(count([det]))  # automatically includes user='Dan'

The key can be temporarily overridden:

.. code-block:: python

    RE(count([det]), user='Tom')  # overrides the setting in RE.md, just once

or deleted:

.. code-block:: python

    del RE.md['user']

In addition to any user-provided metadata, the RunEngine, the devices, and the
plan capture some metadata automatically. For more see, :doc:`metadata`.

Simulate and Introspect Plans
=============================

We have referred to plan as a "sequence of instructions encoding an
experimental procedure." But what's inside a plan really? Bluesky calls each
atomic instruction inside a plan a "message". As a scientist conducting an
experiment, we rarely need to get this far into the weeds of bluesky, but it's
useful to visit just once. Try printing out every message in a couple simple
plans:

.. code-block:: python

    from bluesky.plans import count
    from ophyd.sim import det

    for msg in count([]):
        print(msg)

    for msg in count([det]):
        print(msg)

Again, handling the messages directly is usually only necessary for serious
debugging or deep customization. You can learn more in the :doc:`msg` section.

Building up from simple introspection like the loop above, bluesky includes
some tools for producing more useful, human-readable summaries to answer the
question, "What will this plan do?"

.. ipython:: python

    from bluesky.simulators import summarize_plan
    from bluesky.plans import count, rel_scan
    from ophyd.sim import det, motor
    # Count a detector 3 times.
    summarize_plan(count([det], 3))
    # A 3-step scan.
    summarize_plan(rel_scan([det], motor, -1, 1, 3))

For more possibilities, see :doc:`simulation`.

.. _tutorial_device:

Devices
=======

Theory
------

The notion of a "Device" serves two goals:

* Provide a **standard interface** to all hardware for the sake of generality
  and code reuse.
* **Logically group** individual signals into composite "Devices" that can be
  read together, as a unit, and configured in a coordinated way. Provide a
  human-readable name to this group, with an eye toward later data analysis.

In bluesky's view of the world, there are only three different kinds of devices
used in data acquisition.

* Some devices can be **read**. This includes simple points detectors that
  produce a single number and large CCD detectors that produce big arrays.
* Some devices can be both **read and set**. Setting a motor physically moves
  it to a new position. Setting a temperature controller impels it to gradually
  change its temperature. Setting the exposure time on some detector promptly
  updates its configuration.
* Some devices produce data at a rate too high to be read out in real time, and
  instead **buffer their data externally** in separate hardware or software
  until it can be read out.

Bluesky interacts with all devices via a :doc:`specified interface <hardware>`.
Each device is represented by a Python object with certain methods and
attributes (with names like ``read`` and ``set``). Some of these methods are
asynchronous, such as ``set``, which allows for the concurrent movement of
multiple devices.

Implementation
--------------

`Ophyd <https://nsls-ii.github.io/ophyd>`_, a Python library that was
developed in tandem with bluesky, implements this interface for devices that
speak `EPICS <http://www.aps.anl.gov/epics/>`_. But bluesky is not tied to
ophyd specifically: any Python object may be used, so long as it provides the
specified methods and attributes that bluesky expects. For example, a
separately-developed library has experimentally implemented the bluesky
interface for LabView.

To get a flavor for what it looks like to configure hardware in ophyd,
connecting to an EPICS motor looks like this:

.. code-block:: python

    from ophyd import EpicsMotor

    nano_top_x = EpicsMotor('XF:23ID1-ES{Dif:Nano-Ax:TopX}Mtr', name='nano_top_x')

We have provided both the machine-readable address of the motor on the network,
``'XF:23ID1-ES{Dif:Nano-Ax:TopX}Mtr'`` (in EPICS jargon, the "PV" for
"Process Variable"), and a human-readable name, ``'nano_top_x'``, which will be
used to label the data generated by this motor. When it comes time to analyze
the data, we will be grateful to be dealing with the human-readable label.

The ``EpicsMotor`` device is a logical grouping of many signals. The most
important are the readback (actual position) and setpoint (target position).
All of the signals are summarized thus. The details here aren't important at
this stage: the take-away message is, "There is a lot of stuff to keep track of
about a motor, and a Device helpfully groups that stuff for us."

.. code-block:: none

    In [3]: nano_top_x.summary()
    data keys (* hints)
    -------------------
    *nano_top_x
    nano_top_x_user_setpoint

    read attrs
    ----------
    user_readback        EpicsSignalRO       ('nano_top_x')
    user_setpoint        EpicsSignal         ('nano_top_x_user_setpoint')

    config keys
    -----------
    nano_top_x_acceleration
    nano_top_x_motor_egu
    nano_top_x_user_offset
    nano_top_x_user_offset_dir
    nano_top_x_velocity

    configuration attrs
    ----------
    motor_egu            EpicsSignal         ('nano_top_x_motor_egu')
    velocity             EpicsSignal         ('nano_top_x_velocity')
    acceleration         EpicsSignal         ('nano_top_x_acceleration')
    user_offset          EpicsSignal         ('nano_top_x_user_offset')
    user_offset_dir      EpicsSignal         ('nano_top_x_user_offset_dir')

    Unused attrs
    ------------
    offset_freeze_switch EpicsSignal         ('nano_top_x_offset_freeze_switch')
    set_use_switch       EpicsSignal         ('nano_top_x_set_use_switch')
    motor_is_moving      EpicsSignalRO       ('nano_top_x_motor_is_moving')
    motor_done_move      EpicsSignalRO       ('nano_top_x_motor_done_move')
    high_limit_switch    EpicsSignal         ('nano_top_x_high_limit_switch')
    low_limit_switch     EpicsSignal         ('nano_top_x_low_limit_switch')
    direction_of_travel  EpicsSignal         ('nano_top_x_direction_of_travel')
    motor_stop           EpicsSignal         ('nano_top_x_motor_stop')
    home_forward         EpicsSignal         ('nano_top_x_home_forward')
    home_reverse         EpicsSignal         ('nano_top_x_home_reverse')


.. _tutorial_custom_plans:

Write Custom Plans
==================

Metadata
--------

Hints
-----

Write Custom Callbacks
======================

Export
------

Visualization
-------------

Fitting
-------
