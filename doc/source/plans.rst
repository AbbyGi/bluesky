.. currentmodule:: bluesky.plans

Plans
=====

A *plan* is bluesky's concept of an experimental procedure. Each granular
instruction in a plan is dubbed a *message*.

**For Python developers:** In Python jargon, a plan can be any iterable. It is
typically implemented as a generator but it could just as well be a simple
list. Each message in a plan is a ``blueksy.Msg`` object: a namedtuple
comprised of a semantic command string (e.g., ``"trigger"``), a target device
(if applicable), and positional and keyword arguments.

Executing Plans
---------------

.. note::

    Before you begin, you need a RunEngine to execute plans.

    *Here, we do not configure the RunEngine to save any data.* You may
    already have a RunEngine instance, ``RE``, defined in an IPython profile.
    If ``RE`` is already defined and you want to save data, do not redefine it
    here. Just skip to the next step.

    .. ipython:: python

        from bluesky import RunEngine
        RE = RunEngine({})

Execute the a ``count`` plan, which reads one or more detectors.

.. ipython:: python

    from bluesky.plans import count
    from bluesky.examples import det  # a simulated detector
    RE(count([det]))

It worked, but the data was not displayed. The output is a unique identifer
for the data set(s) generated by the plan. For more useful output, we'll send
the data to ``LiveTable``, which formats the data generated by this plan into a
table.

.. ipython:: python

    from bluesky.callbacks import LiveTable
    RE(count([det]), LiveTable([det]))

Bluesky provides more succinct ways to express this simple task --- read on!
--- but the above syntax shows all the pieces. The RunEngine ``RE`` consumes
the messages from the plan ``count([det])`` and sends the data to
``LiveTable([det])``, which then displays the time, sequence number, and
readings from ``det`` in real time.

.. note::

    Why ``[det]`` with square brackets and not just ``det``? It is common to
    read a *list* of detectors as a group, like ``[det1, det2]``. In the
    special case above where there is only one detector, we write ``[det]``.

Introspecting Plans
-------------------

Separating the *specification* of the plan --- e.g., ``count([det])`` --- from
the *execution* of the plan --- ``RE(count([det]))`` --- permits us to inspect
the plan before running it. It also allows to *modify* a plan on the fly, as
we'll see later on.

Bluesky provides a nice function for summarizing the action of a plan,
``print_summary``. Here, we see that the plan ``count`` opens a "run" (i.e.,
dataset), takes a reading, and marks the end of that.

.. ipython:: python

    from bluesky.plan_tools import print_summary
    from bluesky.examples import motor, det
    from bluesky.plans import count, scan
    print_summary(count([det]))

The plan ``scan`` moves a motor in steps and takes a reading at each position.


.. ipython:: python

    from bluesky.plans import scan, relative_scan
    print_summary(scan([det], motor, 1, 3, 3))

.. ipython:: python
   :suppress:

    motor.set(3)

As you might guess, ``relative_scan`` moves the motor relative to its starting
position. And at the end, ``relative_scan`` then returns it to that starting
position.

.. ipython:: python

    print_summary(relative_scan([det], motor, 1, 3, 3))

(Restoring the original position at the end of a ``relative_scan`` is a
convention carried over from the data collection program SPEC, widely used in
synchrontron science. It's possible to do this same for ``scan``, of course ---
read on.)

Summarizing a plan is also a quick way to check for some types of errors.
More sophisticated error checking is possible and a likely area of future
development in bluesky.


.. note::

    As the name suggests, ``print_summary`` omits some details. To examine the
    full content of a plan, just pass it to ``list()``.
    
    This will not work on plans that are adaptive. Adaptive plans necessarily
    generate their messages on the fly.

Another useful application is  visualization of plan trajectories. For example,
``plot_raster_path`` visualizes the trajectory of a two-motor system. The probe
size, given in "data space" units, provides a sense of this trajectory's
coverage of the sample.

.. ipython:: python

    from bluesky.plan_tools import plot_raster_path
    from bluesky.examples import motor1, motor2, det
    from bluesky.plans import outer_product_scan
    import matplotlib.pyplot as plt
    plan = outer_product_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, True)
    @savefig plot-raster-path-1.png
    plot_raster_path(plan, 'motor1', 'motor2', probe_size=.3)

Combining Plans
---------------

To simply chain plans together, use ``pchain`` to make one long plan.

.. code-block:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, sleep, pchain

    RE(pchain(scan([det], motor, 1, 5, 3),
              sleep(),
              scan([det], motor, 5, 10, 2)))

.. warning::

    Do not combine plans by calling the RunEngine more than once.

    .. code-block:: python

        # Don't do this.
        RE(plan1()); RE(plan2())

        # And also don't do this.
        def bad_idea():
            RE(plan1())
            RE(plan2())

    In the event of an error or interruptions, the RunEngine can do more to
    recover if it maintains control. In the bad example above, it loses control
    between completing ``plan1`` and beginning ``plan2``.
    
    Instead, use ``pchain`` (see above) or ``yield from`` (see below) to make
    one long plan.

What if want to ``print`` or do other activities between executing the plans?
There is another way to combine plans to accomodate this.

.. code-block:: python

    def make_master_plan():
        # Scan and read detectors 1 and 2.
        yield from scan([det1, det2], motor, 1, 5, 10)
        print('Now plan1 is finished. Moving on to plan2.')
        # Scan again and just read detector 1.
        yield from relative_scan([det1], motor, 5, 10, 10)

    RE(make_master_plan())

The plan can employ control flow (``if`` blocks, ``for`` loops, etc.) and the
full power of the Python language.

.. code-block:: python

    def make_master_plan():
        "Run a plan several times, changing the step size each time."
        for num in range(5, 10):
            # Change the number of steps in the plan in each loop
            yield from scan([det1, det2], motor, 1, 5, num)

An Aside on ``yield`` and ``yield from``
----------------------------------------

This is a very brief primer on the Python syntax ``yield`` and ``yield from``.

A Python *function* returns once:

.. ipython:: python

    def f():
        return 1

    f()

A Python *generator* in like a function with multiple exit points. Calling
generator produces an *iterator* that yields one value at a time. After
each ``yield`` statement, its execution is suspended.

.. ipython:: python

    def f():
        yield 1
        yield 2

We can exahust the generator (i.e., get all its values) by calling ``list()``.

.. ipython:: python

    list(f())

We can get one value at a time by calling ``next()``

.. ipython:: python

    it = f()
    next(it)
    next(it)

or by looping through the values.

.. ipython:: python

    for val in f():
        print(val)

To examine what is happening when, we can add prints.

.. ipython:: python

    def f():
        print("before 1")
        yield 1
        print("before 2")
        yield 2

.. ipython:: python

    it = f()
    next(it)
    next(it)

Notice that execution is suspended after the first yield statement. The
second ``print`` is not run until we resume execution by requesting a second
value. This is a useful feature of generators: they can express "lazy"
execution.

Generators can delegate to other generators using ``yield from``. This is
syntax we commonly use to combine plans.

.. ipython:: python

    def double_f():
        yield from f()
        yield from f()

.. ipython:: python

    list(double_f())

Built-in Plans
--------------

The plans are organized like a deli menu. A variety of pre-assembled plans
are provided, like a B.L.T. sandwich on a menu.  But you can also build your
own plans by mixing the individual ingredients, the "stub" plans.

The pre-assembled plans and the "stub" plans are catalogued below. Notice that
their names are links: follow the links for usage details and more examples.

Pre-assembled Plans
+++++++++++++++++++

.. autosummary::
   :toctree:
   :nosignatures:

   count
   scan
   relative_scan
   list_scan
   relative_list_scan
   log_scan
   relative_log_scan
   inner_product_scan
   outer_product_scan
   relative_inner_product_scan
   relative_outer_product_scan
   scan_nd
   spiral
   spiral_fermat
   relative_spiral
   relative_spiral_fermat
   adaptive_scan
   relative_adaptive_scan
   tweak
   fly

Stub Plans (ingredients for remixing)
+++++++++++++++++++++++++++++++++++++

.. autosummary::
   :nosignatures:
   :toctree:

    trigger_and_read
    abs_set
    rel_set
    wait
    sleep
    checkpoint
    clear_checkpoint
    pause
    deferred_pause
    open_run
    close_run
    create
    save
    trigger
    read
    monitor
    unmonitor
    kickoff
    collect
    configure
    stage
    unstage
    subscribe
    unsubscribe
    wait_for
    null
    one_1d_step
    one_nd_step

Writing Custom Plans
---------------------

Reconstructing ``count`` from scratch
+++++++++++++++++++++++++++++++++++++

In this section we will build a custom plan out of the stub plans above.
To make clear which of the variables below come from ``bluesky.plans`` we will
import the plans module like so.

.. code-block:: python

    import bluesky.plans as bp

What we referred to use ``count``, ``scan``, and so on above will in this
section be referred to as ``bp.count``, ``bp.scan``, etc.

.. code-block:: python

    from bluesky.examples import det1, det2
    import bluesky.plans as bp

The basic usage of the ``count`` plan generates one "run" (i.e., dataset)
with one "event" (i.e., one bundle of readings from the detectors, one row in
a table of the data).

.. code-block:: python

    dets = [det1, det2]
    RE(bp.count(dets))

The ``num`` argument enables multiple events (rows) in one run.

.. code-block:: python

    # one 'run' with three 'events'
    RE(bp.count(dets, num=3))

If we didn't provide a num option, how could you make one yourself?

A tempting --- but wrong! --- possibility is to loop over calls to
``RE(bp.count(dets))``.

.. code-block:: python

    # Don't do this!
    for _ in range(3):
        RE(bp.count(dets))

As stated above, this ruins error-recovery and interruption recovery. It's much
better to do the loop inside a custom plan, which we'll dub ``multicount``.

.. code-block:: python

    def multicount(dets):
        for _ in range(3):
            yield from bp.count(dets)

    RE(multicount(dets))

In fact, instead of hard-coding 3, we could make it an argument configurable
by the user. We can make tha configuration optional by providing 3 as a
default.

.. code-block:: python

    def multicount(dets, num=3):
        for _ in range(num):
            yield from bp.count(dets)

But this still creates three runs --- there datasets --- for what we'd rather
think of as three events (rows) in one run. To fix that, we'll have to dive
deeper, re-implementing ``count`` from scratch.

.. code-block:: python

    def multicount(dets, num=3):
        "Creates a single 'run'"
        for det in dets:
            yield from bp.stage(det)
        yield from bp.open_run()
        for _ in range(num):
            yield from bp.trigger_and_read(dets)
        yield from bp.close_run()
        for det in dets:
            yield from bp.unstage(det)

Starting from the middle and explaining outward:

* The ``trigger_and_read`` plan generates an "event" (a row of data) from
  reading ``dets``. This happens inside of a loop, ``num`` times.
* The ``open_run`` and ``close_run`` plans designate the beginning and end of
  a dataset.
* The ``stage`` and ``unstage`` plans prime the hardware for data collection.
  For some devices, this has no affect at all. But for others, it ensures that
  the device is put into a ready, triggerable state and then restored to
  standby at the end of the plan.

Customizing metadata
++++++++++++++++++++

Metadata can stored in a persistent file, specified by the user interactively
at execution time, or incorporated in a plan.

To incorporate metadata in a plan, pass it to the ``open_run`` plan.

.. code-block:: python

    def multicount(dets, num=3):
        md = {'plan_name': 'multicount',
              'num': num}
        for det in dets:
            yield from bp.stage(det)
        yield from bp.open_run(md=md)
        <snip>

(Just to be clear, ``<snip>`` is not code --- we're just indicating that we
omitted the rest of this plan for brevity. The rest would go the same as it did
above.)

All of the pre-assembled plans also accept an ``md`` argument, which makes
it easy for a user-defined plan to pass in extra metadata.

.. code-block:: python

    def master_plan():
        # ... insert code here to close shutter ...
        yield from  bp.count([det], md={'is_dark_frame': True})
        # ... insert code here to open shutter ...
        yield from  bp.count([det], md={'is_dark_frame': False})


To make your own plans' metadata customizable in the same way, use the
following pattern.

.. code-block:: python

    from collections import ChainMap

    def multicount(dets, num=3, md=None):
        if md is None:
            md = {}
        md = ChainMap(md, 
                      {'plan_name': 'multicount',
                       'num': num})
        <snip>

For example, if the plan is called with the arguments
``multicount([det], md={'plan_name': 'watermelon'})``, then ``watermelon`` will
override ``multicount`` as the recorded plan name.

.. note::

    The built-in Python data structure ``ChainMap`` is a chain of mappings
    (i.e., a sequence of dicts). It gives prioity to a the first mapping that
    defines a given key.
    
    .. ipython:: python
       :suppress:

        from collections import ChainMap

    .. ipython:: python
    
        m = ChainMap({'a': 1}, {'a': 2, 'b': 3})
        m['a']
        m['b']

    Thus, ``a=1`` takes precedence of ``a=2``. We use it to give user-provided
    metadata precedence over a plan's hard-coded metadata in the event of a
    key collision.

    See the `relevant section of the Python documentation <https://docs.python.org/3/library/collections.html#collections.ChainMap>`_
    for more.

Plan Preprocessors
------------------

These "preprocessors" take in a plan and modify its contents on the fly.
For example, ``relative_set`` rewrites all positions to be relative to the
initial position.

.. code-block:: python

    def relative_scan(detectors, motor, start, stop, num):
        absolute = scan(detectors, motor, start, stop, num)
        relative = relative_set(absolute, [motor])
        yield from relative

This is a subtle but remarkably powerful feature.

.. autosummary::
   :nosignatures:
   :toctree:

    finalize_wrapper
    subs_wrapper
    inject_md_wrapper
    run_wrapper
    monitor_during_wrapper
    fly_during_wrapper
    baseline_wrapper
    relative_set_wrapper
    reset_positions_wrapper
    stage_wrapper
    lazily_stage_wrapper


These wrappers operate on a generator *instance*, like `scan(...)`. There are
corresponding functions that operate on a generator *function*, like `scan`.
They are named ``*_decorator``, corresponding to each ``*_wrapper`` above.

.. code-block:: python

    # Using a warpper to modify a generator instance
    def relative_scan(detectors, motor, start, stop, num):
        absolute = scan(detectors, motor, start, stop, num)
        relative = relative_set(absolute, [motor])
        yield from relative

    # Using a decorator to modify a generator function
    def relative_scan(detectors, motor, start, stop, num):

        @relative_set_decorator([motor])
        def inner():
            yield from scan(detectors, motor, start, stop, num)

        yield from inner()

Plan Utilities
--------------

.. autosummary::

    pchain
    msg_mutator
    plan_mutator
    single_gen
    broadcast_msg
    repeater
    caching_repeater
    make_decorator

Object-Oriented-Style Plans
---------------------------

These provide an alternative interface to plans. The plan becomes a reusable
object, whose parameters can be adjusted interactively between uses.

.. ipython:: python

    from bluesky.plans import Scan
    from bluesky.examples import motor, det, det3
    plan = Scan([det], motor, 1, 5, 10)
    RE(plan)
    RE(plan)

Any of the plan's parameters can be updated individually.

.. ipython:: python

    plan.num = 4  # change number of data points from 10 to 4
    RE(plan)
    plan.detectors.append(det3)  # add another detector
    RE(plan)

The ``set`` method is a convenient way to update multiple parameters at once.

.. ipython:: python

    plan.set(start=20, stop=25)

.. autosummary::
   :nosignatures:
   :toctree:

    Count
    Scan
    RelativeScan
    ListScan
    RelativeListScan
    LogScan
    RelativeLogScan
    InnerProductScan
    OuterProductScan
    RelativeInnerProductScan
    RelativeOuterProductScan
    ScanND
    SpiralScan
    SpiralFermatScan
    RelativeSpiralScan
    RelativeSpiralFermatScan
    AdaptiveScan
    RelativeAdaptiveScan
    Tweak
