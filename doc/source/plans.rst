.. currentmodule:: bluesky.plans

Plans
=====

A *plan* is bluesky's concept of an experimental procedure. Each granular
instruction in a plan is dubbed a *message*.

In Python jargon, a plan can be any iterable. It could be a simple list or
a generator, a concept which is addressed in detail below. The
:ref:`details of the messages themselves <msg>` are not important for
understanding what follows.

.. note::

    This document is addressing three different audiences, and we have
    different setup instructions for each.

    1. If you are a user at NSLS-II taking real data, do nothing. You already
       have a RunEngine defined as the variable ``RE`` by your IPython profile,
       and it is configured to save data.

    2. If you are a user at NSLS-II and you want to experiment with plans
       *without saving data*, start a new IPython session and define a clean
       RunEngine, which will not be configured to save data.

        .. code-block:: python

            from bluesky import RunEngine
            RE = RunEngine({})

       Close IPython when you are done, lest someone accidentally try to take
       real data with your toy RunEngine!

    3. If you are a scientist and Python user casually exploring this library,
       just define a toy ``RunEngine`` instance and carry on:

        .. code-block:: python

            from bluesky import RunEngine
            RE = RunEngine({})


Executing Plans
---------------

Define a ``count`` plan, which reads one or more detectors, and pass it to the
RunEngine for execution.

.. ipython:: python

    from bluesky.plans import count
    from bluesky.examples import det  # a simulated detector
    RE(count([det]))

It worked, but the data was not displayed. The return value is a unique
identifer for the data set(s) generated by the plan. To print something more
useful to the screen, we'll send the data to ``LiveTable``, which formats the
data generated by this plan into a table.

.. ipython:: python

    from bluesky.callbacks import LiveTable
    RE(count([det]), LiveTable([det]))

Bluesky provides more succinct ways to express this simple task --- read on!
--- but the above syntax shows all the pieces. The RunEngine ``RE`` consumes
the messages from the plan ``count([det])`` and sends the data to
``LiveTable([det])``, which then displays the time, sequence number, and
readings from ``det`` in real time.

.. note::

    Why ``[det]`` and not just ``det``? It is common to read a *list* of
    detectors as a group, like ``[det1, det2]``.

Introspecting Plans
-------------------

Separating the *specification* of the plan --- e.g., ``count([det])`` --- from
the *execution* of the plan --- ``RE(count([det]))`` --- permits us to inspect
the plan before running it. It also allows to *modify* a plan on the fly, as
we'll see later on.

Bluesky provides a nice function for summarizing the action of a plan,
``print_summary``. Here, we see that the plan ``count`` opens a "run" (i.e.,
dataset), takes a reading, and marks the end of that run.

.. ipython:: python

    from bluesky.plan_tools import print_summary
    from bluesky.examples import motor, det
    from bluesky.plans import count, scan
    print_summary(count([det]))

The plan ``scan`` moves a motor in steps and takes a reading at each position.


.. ipython:: python

    from bluesky.plans import scan, relative_scan
    print_summary(scan([det], motor, 1, 3, 3))

.. ipython:: python
   :suppress:

    motor.set(3)

As you might guess, ``relative_scan`` moves the motor relative to its starting
position. And at the end, ``relative_scan`` then returns it to that starting
position.

.. ipython:: python

    print_summary(relative_scan([det], motor, 1, 3, 3))

(Restoring the original position at the end of a ``relative_scan`` is a
convention carried over from the data collection program SPEC, widely used in
synchrontron science. It's possible to do this same for ``scan``, of course ---
read on.)

Summarizing a plan is also a quick way to check for some types of errors.
More sophisticated error checking is possible and a likely area of future
development in bluesky.


.. note::

    As the name suggests, ``print_summary`` omits some details. To examine the
    full content of a plan, just pass it to ``list()``.
    
    This will not work on plans that are adaptive. Adaptive plans necessarily
    generate their messages on the fly.

Another useful application is  visualization of plan trajectories. For example,
``plot_raster_path`` visualizes the trajectory of a two-motor system. The probe
size, given in "data space" units, provides a sense of this trajectory's
coverage of the sample.

.. ipython:: python

    from bluesky.plan_tools import plot_raster_path
    from bluesky.examples import motor1, motor2, det
    from bluesky.plans import outer_product_scan
    import matplotlib.pyplot as plt
    plan = outer_product_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, True)
    @savefig plot-raster-path-1.png
    plot_raster_path(plan, 'motor1', 'motor2', probe_size=.3)

Combining Plans
---------------

To simply chain plans together, use ``pchain`` to make one long plan.

.. code-block:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, sleep, pchain

    RE(pchain(scan([det], motor, 1, 5, 3),
              sleep(1),
              scan([det], motor, 5, 10, 2)))

.. warning::

    Do not combine plans by calling the RunEngine more than once.

    .. code-block:: python

        # Don't do this.
        RE(plan1()); RE(plan2())

        # And also don't do this.
        def bad_idea():
            RE(plan1())
            RE(plan2())

    In the event of an error or interruptions, the RunEngine can do more to
    recover if it maintains control. In the bad example above, it loses control
    between completing ``plan1`` and beginning ``plan2``.
    
    Instead, use ``pchain`` (see above) or ``yield from`` (see below) to make
    one long plan.

What if want to ``print`` or do other activities between executing the plans?
There is another way to combine plans to accomodate this.

.. code-block:: python

    def master_plan():
        # Scan and read detectors 1 and 2.
        yield from scan([det1, det2], motor, 1, 5, 10)
        print('Now plan1 is finished. Moving on to plan2.')
        # Scan again and just read detector 1.
        yield from relative_scan([det1], motor, 5, 10, 10)

    RE(master_plan())

The plan can employ control flow (``if`` blocks, ``for`` loops, etc.) and the
full power of the Python language.

.. code-block:: python

    def master_plan():
        "Run a plan several times, changing the step size each time."
        for num in range(5, 10):
            # Change the number of steps in the plan in each loop
            yield from scan([det1, det2], motor, 1, 5, num)

An Aside on ``yield`` and ``yield from``
----------------------------------------

This is a very brief primer on the Python syntax ``yield`` and ``yield from``.

A Python *function* returns once:

.. ipython:: python

    def f():
        return 1

    f()

A Python *generator* is like a function with multiple exit points. Calling a
generator produces an *iterator* that yields one value at a time. After
each ``yield`` statement, its execution is suspended.

.. ipython:: python

    def f():
        yield 1
        yield 2

We can exhaust the generator (i.e., get all its values) by calling ``list()``.

.. ipython:: python

    list(f())

We can get one value at a time by calling ``next()``

.. ipython:: python

    it = f()
    next(it)
    next(it)

or by looping through the values.

.. ipython:: python

    for val in f():
        print(val)

To examine what is happening when, we can add prints.

.. ipython:: python

    def f():
        print("before 1")
        yield 1
        print("before 2")
        yield 2

.. ipython:: python

    it = f()
    next(it)
    next(it)

Notice that execution is suspended after the first yield statement. The
second ``print`` is not run until we resume execution by requesting a second
value. This is a useful feature of generators: they can express "lazy"
execution.

Generators can delegate to other generators using ``yield from``. This is
syntax we commonly use to combine plans.

.. ipython:: python

    def double_f():
        yield from f()
        yield from f()

.. ipython:: python

    list(double_f())

Built-in Plans
--------------

The plans are organized like a deli menu. A variety of pre-assembled plans
are provided, like a B.L.T. sandwich on a menu.  But you can also build your
own plans by mixing the individual ingredients, the "stub" plans.

The pre-assembled plans and the "stub" plans are catalogued below. Notice that
their names are links: follow the links for usage details and more examples.

Pre-assembled Plans
+++++++++++++++++++

These include plans with one- and multi-dimensional trajectories, plans with
adaptive step sizes, and a plan that prompts the user for input between each
step.

.. autosummary::
   :toctree:
   :nosignatures:

   count
   scan
   relative_scan
   list_scan
   relative_list_scan
   log_scan
   relative_log_scan
   inner_product_scan
   outer_product_scan
   relative_inner_product_scan
   relative_outer_product_scan
   scan_nd
   spiral
   spiral_fermat
   relative_spiral
   relative_spiral_fermat
   adaptive_scan
   relative_adaptive_scan
   tweak
   fly

Stub Plans (ingredients for remixing)
+++++++++++++++++++++++++++++++++++++

.. autosummary::
   :nosignatures:
   :toctree:

    trigger_and_read
    abs_set
    rel_set
    wait
    sleep
    checkpoint
    clear_checkpoint
    pause
    deferred_pause
    open_run
    close_run
    create
    save
    trigger
    read
    monitor
    unmonitor
    kickoff
    collect
    configure
    stage
    unstage
    subscribe
    unsubscribe
    wait_for
    null
    one_1d_step
    one_nd_step

We also have a number of wrapper functions, decorators, and utility functions
that make building these easier. Examples and API documentation are in later
sections, below.

Simple Custom Plans
-------------------

Loops
+++++

TO DO

Asynchronous data streams
+++++++++++++++++++++++++

TO DO

Pauses
++++++

TO DO

Customizing metadata (high level)
+++++++++++++++++++++++++++++++++

Metadata can be loaded from a persistent file, specified by the user
interactively at execution time, or incorporated in a plan.

All of the pre-assembled plans also accept an ``md`` argument, which makes
it easy for a user-defined plan to pass in extra metadata.

.. code-block:: python

    def master_plan():
        # ... insert code here to close shutter ...
        yield from bp.count([det], md={'is_dark_frame': True})
        # ... insert code here to open shutter ...
        yield from bp.count([det], md={'is_dark_frame': False})


To enable users to pass in metadata that combines with and potentially
overrides the hard-coded metadata, use the following pattern:

.. code-block:: python

    from collections import ChainMap

    def multicount(dets, num=3, *, md=None):
        if md is None:
            md = {}
        md = ChainMap(md, 
                      {'plan_name': 'multicount',
                       'num': num})
        # etc. -- the rest of multicount is unchanged

For example, if the plan is called with the arguments
``multicount([det], md={'plan_name': 'watermelon'})``, then ``watermelon`` will
override ``multicount`` as the recorded plan name.

.. note::

    The built-in Python data structure ``ChainMap`` is a chain of mappings
    (i.e., a sequence of dicts). It gives prioity to a the first mapping that
    defines a given key.
    
    .. ipython:: python
       :suppress:

        from collections import ChainMap

    .. ipython:: python
    
        m = ChainMap({'a': 1}, {'a': 2, 'b': 3})
        m['a']
        m['b']

    Thus, ``a=1`` takes precedence of ``a=2``. We use it to give user-provided
    metadata precedence over a plan's hard-coded metadata in the event of a
    key collision.

    See the `relevant section of the Python documentation <https://docs.python.org/3/library/collections.html#collections.ChainMap>`_
    for more.

Plan Preprocessors
------------------

These "preprocessors" take in a plan and modify its contents on the fly.  For
example, ``relative_set_wrapper`` rewrites all positions to be relative to the
initial position.

.. code-block:: python

    def relative_scan(detectors, motor, start, stop, num):
        absolute = scan(detectors, motor, start, stop, num)
        relative = relative_set_wrapper(absolute, [motor])
        yield from relative

This is a subtle but remarkably powerful feature.

Wrappers like ``relative_set_wrapper`` operate on a generator *instance*,
like ``scan(...)``. There are corresponding decorator functions like
``relative_set_decorator`` that operate on a generator
*function* itself, like ``scan``.

.. code-block:: python

    # Using a decorator to modify a generator function
    def relative_scan(detectors, motor, start, stop, num):

        @relative_set_decorator([motor])  # unfamiliar syntax? -- see box below
        def inner_relative_scan():
            yield from scan(detectors, motor, start, stop, num)

        yield from inner_relative_scan()

Incidentally, the name ``inner_relative_scan`` is just an internal variable,
so why did we choose such a verbose name? Why not just name it ``f``? That
would work, of course, but using a descriptive name can make debugging easier.
When navigating gnarly, deeply nested tracebacks, it helps if internal variables
have clear names.

.. note::

    The decorator syntax --- the ``@`` --- is a succinct way of passing a
    function to another function.

    This:

    .. code-block:: python

        @g
        def f(...):
            pass

        f(...)

    is equivalent to

    .. code-block:: python

        g(f)(...)

Revisiting the example of a custom plan from above, we can use the decorators
to reduce boilerplate. These two implementation yield exactly the same sequence
of messages.

Before:

.. code-block:: python

    def multicount(dets, num=3, *, md=None):
        for det in dets:
            yield from bp.stage(det)
        yield from bp.open_run(md=md)
        for _ in range(num):
            yield from bp.trigger_and_read(dets)
        yield from bp.close_run()
        for det in dets:
            yield from bp.unstage(det)

After:

.. code-block:: python

    def multicount(dets, num=3, *, md=None):

        @bp.stage_decorator(dets)
        @bp.run_decorator(md=md)
        def inner_multicount():
            for _ in range(num):
                yield from bp.trigger_and_read(dets)

        yield from inner_multicount()

We gained some syntactical complexity but shedded some boilerplate code.

Built-in Preprocessors
++++++++++++++++++++++

Each of the following functions, named ``<something>_wrapper``, operates on
a generator instance. There are corresponding functions named
``<something_decorator>`` that operate on a generator function.

.. autosummary::
   :nosignatures:
   :toctree:

    finalize_wrapper
    subs_wrapper
    inject_md_wrapper
    run_wrapper
    monitor_during_wrapper
    fly_during_wrapper
    baseline_wrapper
    relative_set_wrapper
    reset_positions_wrapper
    stage_wrapper
    lazily_stage_wrapper

Custom Preprocessors
++++++++++++++++++++

TO DO

How Plans Handle Exceptions
---------------------------

If an exception is raised, the RunEngine gives the plan the opportunity to
catch the exception and either handle it or merely yield some "clean up"
messsages before re-raising the exception and killing plan execution.

.. code-block:: python

    def plan_with_cleanup():
        try:
            yield from main_plan()
        except Exception:
            # Catch the exception long enough to clean up.
            yield from cleanup_plan()
            raise  # Re-raise the exception.

The ``finalize`` preprocessor provides a succinct way of applying this pattern.

.. code-block:: python

    def plan_with_cleanup():
        yield from finalize(main_plan(), cleanup_plan())

The exception in question may originate from the plan itself or from the
RunEngine when is attempts to execute the plan.

Advanced Custom Plans
---------------------

Reconstructing ``count`` from scratch
+++++++++++++++++++++++++++++++++++++

In this section we will build a custom plan out of the stub plans above.
To make clear which of the variables below come from ``bluesky.plans`` we will
import the plans module like so.

.. code-block:: python

    import bluesky.plans as bp

What we referred to as ``count``, ``scan``, and so on above will in this
section be referred to as ``bp.count``, ``bp.scan``, etc.

.. code-block:: python

    from bluesky.examples import det1, det2
    import bluesky.plans as bp

The basic usage of the ``count`` plan generates one "run" (i.e., dataset)
with one "event" (i.e., one bundle of readings from the detectors, one row in
a table of the data).

.. code-block:: python

    dets = [det1, det2]
    RE(bp.count(dets))

The ``num`` argument enables multiple events (rows) in one run.

.. code-block:: python

    # one 'run' with three 'events'
    RE(bp.count(dets, num=3))

If we didn't provide a num option, how could you make one yourself?

A tempting --- but wrong! --- possibility is to loop over calls to
``RE(bp.count(dets))``.

.. code-block:: python

    # Don't do this!
    for _ in range(3):
        RE(bp.count(dets))

As stated above, this ruins error-recovery and interruption recovery. It's much
better to do the loop inside a custom plan, which we'll dub ``multicount``.

.. code-block:: python

    def multicount(dets):
        for _ in range(3):
            yield from bp.count(dets)

    RE(multicount(dets))

In fact, instead of hard-coding 3, we could make it an argument configurable
by the user. We can make the configuration optional by providing 3 as a
default.

.. code-block:: python

    def multicount(dets, num=3):
        for _ in range(num):
            yield from bp.count(dets)

But this still creates three runs --- three datasets --- for what we'd rather
think of as three events (rows) in one run. To fix that, we'll have to dive
deeper, re-implementing ``count`` from scratch.

.. code-block:: python

    def multicount(dets, num=3):
        "Creates a single 'run'"
        for det in dets:
            yield from bp.stage(det)
        yield from bp.open_run()
        for _ in range(num):
            yield from bp.trigger_and_read(dets)
        yield from bp.close_run()
        for det in dets:
            yield from bp.unstage(det)

Starting from the middle and explaining outward:

* The ``trigger_and_read`` plan generates an "event" (a row of data) from
  reading ``dets``. This happens inside of a loop, ``num`` times.
* The ``open_run`` and ``close_run`` plans designate the beginning and end of
  a dataset.
* The ``stage`` and ``unstage`` plans prime the hardware for data collection.
  For some devices, this has no effect at all. But for others, it ensures that
  the device is put into a ready, triggerable state and then restored to
  standby at the end of the plan.

Plans with adaptive logic
+++++++++++++++++++++++++

TO DO

Customizing metadata (low level)
++++++++++++++++++++++++++++++++

In plans built from scatch, such as our ``multicount`` example above, pass
metadata to the ``open_run`` stub plan.

.. code-block:: python

    def multicount(dets, num=3):

        # Define custom metadata.
        md = {'plan_name': 'multicount',
              'num': num}

        for det in dets:
            yield from bp.stage(det)
        yield from bp.open_run(md=md)  # HERE
        for _ in range(num):
            yield from bp.trigger_and_read(dets)
        yield from bp.close_run()
        for det in dets:
            yield from bp.unstage(det)

Plan Utilities
--------------

These are useful utilities for defining custom plans and plan preprocessors.

.. autosummary::
   :toctree:
   :nosignatures:

    pchain
    msg_mutator
    plan_mutator
    single_gen
    broadcast_msg
    repeater
    caching_repeater
    make_decorator

Object-Oriented-Style Plans
---------------------------

These provide an alternative interface to plans that is convenient for some
workflows. The plan becomes a reusable object: unlike a generator instance, it
is not "exhausted" after the first use.

.. code-block:: python

    from bluesky.plans import Scan
    from bluesky.examples import motor, det, det3
    plan = Scan([det], motor, 1, 3, 3)  # a "reusable" object-oriented plan

When it is passed to the RunEngine (in general, when it is iterated over) it
re-instantiates a generator automatically using the same parameters.

.. code-block:: python

    RE(plan)  # This is the same as before...
    RE(plan)  # ...but this would not work with generators, only the OO plans.

For each parameter there is an attribute that can be adjusted interactively.

.. code-block:: python

    plan.num = 4  # change number of data points from 10 to 4
    plan.detectors.append(det3)  # add another detector

The ``set`` method is a convenient way to update multiple parameters at once.

.. code-block:: python

    plan.set(start=20, stop=25)

Built-in Object-Oriented Plans
++++++++++++++++++++++++++++++

For each of the "pre-assembled" plans catalogued above, bluesky ships an
object-oriented counterpart.

.. autosummary::
   :nosignatures:
   :toctree:

    Count
    Scan
    RelativeScan
    ListScan
    RelativeListScan
    LogScan
    RelativeLogScan
    InnerProductScan
    OuterProductScan
    RelativeInnerProductScan
    RelativeOuterProductScan
    ScanND
    SpiralScan
    SpiralFermatScan
    RelativeSpiralScan
    RelativeSpiralFermatScan
    AdaptiveScan
    RelativeAdaptiveScan
    Tweak

Custom Object-Oriented Plans
++++++++++++++++++++++++++++

To define a custom object-oriented Plan, follow this pattern. Here we define
``Scan``, the object-oriented counterpart to ``scan``.

.. code-block:: python

    from bluesky.plans import Plan

    class Scan(Plan):
        __doc__ = scan.__doc__  # mirror the docstring of 'scan'

        def __init__(self, detectors, motor, start, stop, num, *, md=None):
            self.detectors = detectors
            self.motor = motor
            self.start = start
            self.stop = stop
            self.num = num
            self.md = md

        def _gen(self):
            return scan(self.detectors, self.motor, self.start, self.stop,
                        self.num, md=self.md)


This ``__init__`` method contains a lot of boilerplate code, assigning an
attribute for each argument. For cases like this where a plan takes zero or
more required arguments plus ``md``, the ``Plan`` class provides a shortcut
using metaclass magic.

Optionally, the definition of ``__init__`` can be entirely removed and replaced
by the line

.. code-block:: python

    _fields = ['detectors', 'motor', 'start', 'stop', 'num']

which ``Plan`` uses to auto-generate an ``__init__`` at class definition
time. If that is a little too "magical" for your taste, feel free to skip it
and just write out the ``__init__`` method, as we did in the example above.

SPEC-like API with Global State
-------------------------------

Some scientists are familiar with `SPEC <http://www.certif.com/spec.html>`_,
a domain-specific language for hardware control. It is possible to imitate the
SPEC workflow on top of bluesky. Of course, we still adhere to the Python
syntax so that we can employ the full power of the general-purpose Python
language.

The "SPEC-like" plans are extensions of the pre-assembled plans, reusing the
same internal logic under a different interface.

Differences from non-SPEC-like plans
++++++++++++++++++++++++++++++++++++

To see the differences, compare the SPEC-like plan ``ascan`` its non-SPEC-like
counterpart ``scan``.

.. code-block:: python

    # non-SPEC-like
    RE(scan([det], motor, 1, 5, 5))

    # SPEC-like
    gs.DETS = [det]
    RE(ascan(motor, 1, 5, 4))

* **Global list of detectors.** ``scan`` expects a list of detectors --- e.g.,
  ``[det]`` --- as its first argument. ``ascan`` obtains the detector list
  implicitly by checking the current value of ``gs.DETS``.
* **Globally configured subscriptions.** ``ascan`` bakes in subscriptions to
  ``LiveTable`` and ``LivePlot`` by default. These defaults are configurable
  --- see below.
* **Arguments' names and ordering.** The signatures match those in the SPEC
  manual. In some cases they are different from the signature of their non-SPEC
  counterparts, which adhere more closely to idiomatic scientific Python.
  What ``scan`` calls "start" and "stop" ``ascan`` calls "start" and "finish".
* **Count strides, not points.** Following the convention in SPEC, the
  SPEC-like plans expect the number of "intervals" (strides) N, leading to N +
  1 points. In all other parts of bluesky, we adhere to the Python/scipy
  convention, expecting the user to input the number of points. To avoid
  confusion, the argument names are different: non-SPEC-like plans have a
  ``num`` argument; SPEC-like plans have ``intervals`` instead.


