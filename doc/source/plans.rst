.. currentmodule:: bluesky.plans

Plans
=====

A *plan* is bluesky's concept of an experimental procedure. Each granular
instruction in a plan is dubbed a *message*.

In Python jargon, a plan can be any iterable. It could be a simple list or
a generator, a concept which is addressed in detail below. The
:ref:`details of the messages themselves <msg>` are not important for
understanding what follows.

.. note::

    This document is addressing three different audiences, and we have
    different setup instructions for each.

    1. If you are a user at NSLS-II taking real data, do nothing. You already
       have a RunEngine defined as the variable ``RE`` by your IPython profile,
       and it is configured to save data.

    2. If you are a user at NSLS-II and you want to experiment with plans
       *without saving data*, start a new IPython session and define a clean
       RunEngine, which will not be configured to save data.

        .. code-block:: python

            from bluesky import RunEngine
            RE = RunEngine({})

       Close IPython when you are done, lest someone accidentally try to take
       real data with your "toy" RunEngine!

    3. If you are a scientist and Python user casually exploring this library,
       just define a ``RunEngine`` instance and carry on:

        .. code-block:: python

            from bluesky import RunEngine
            RE = RunEngine({})


Executing Plans
---------------

Define a :func:`count` plan, which reads one or more detectors, and pass it to the
RunEngine for execution.

.. ipython:: python
    :suppress:

    from bluesky import RunEngine
    RE = RunEngine({})

.. ipython:: python

    from bluesky.plans import count
    from bluesky.examples import det  # a simulated detector
    RE(count([det]))

It worked, but the data was not displayed. The return value is a unique
identifer for the data set(s) generated by the plan. To print something more
useful to the screen, we'll send the data to ``LiveTable``, which formats the
data generated by this plan into a table.

.. ipython:: python

    from bluesky.callbacks import LiveTable
    RE(count([det]), LiveTable([det]))

Bluesky provides more succinct ways to express this simple task --- read on!
--- but the above syntax shows all the pieces. The RunEngine ``RE`` consumes
the messages from the plan ``count([det])`` and sends the data to
``LiveTable([det])``, which then displays the time, sequence number, and
readings from ``det`` in real time.

.. note::

    Why ``[det]`` and not just ``det``? It is common to read a *list* of
    detectors as a group, like ``[det1, det2]``.

Introspecting Plans
-------------------

Separating the *specification* of the plan --- e.g., ``count([det])`` --- from
the *execution* of the plan --- ``RE(count([det]))`` --- permits us to inspect
the plan before running it. It also allows to modify a plan on the fly, as
we'll see :ref:`later below <preprocessors>`.

Bluesky provides a nice function for summarizing the action of a plan,
``print_summary``. Here, we see that the plan :func:`count` opens a "run" (i.e.,
dataset), takes a reading, and marks the end of that run.

.. ipython:: python

    from bluesky.plan_tools import print_summary
    from bluesky.examples import det
    from bluesky.plans import count
    print_summary(count([det]))

The plan :func:`scan` moves a motor in steps and takes a reading at each position.


.. ipython:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, relative_scan
    print_summary(scan([det], motor, 1, 3, 3))

.. ipython:: python
   :suppress:

    motor.set(3)

As you might guess, ``relative_scan`` moves the motor relative to its starting
position. And at the end, ``relative_scan`` then returns it to that starting
position.

.. ipython:: python

    print_summary(relative_scan([det], motor, 1, 3, 3))

(Restoring the original position at the end of a ``relative_scan`` is a
convention carried over from the data collection program SPEC, widely used in
synchrontron science. It's possible to do this same for :func:`scan`, of course ---
read on.)

Summarizing a plan is also a quick way to check for some types of errors.
More sophisticated error checking is possible and a likely area of future
development in bluesky.


.. note::

    As the name suggests, ``print_summary`` omits some details. To examine the
    full content of a plan, just pass it to ``list()``.
    
    This will not work on plans that are adaptive. Adaptive plans necessarily
    generate their messages on the fly.

Another useful application is  visualization of plan trajectories. For example,
``plot_raster_path`` visualizes the trajectory of a two-motor system. The probe
size, given in "data space" units, provides a sense of this trajectory's
coverage of the sample.

.. note::

    In IPython, before running examples that generate plots, you may need to
    first run this command once:

    .. code-block:: python

        %matplotlib

    or, if you are using a Jupyter notebook,

    .. code-block:: python

        %matplotlib notebook

    Then, the following example should spawn a new window with a plot in it.

    See
    `the relevant section of the IPython documentation <https://ipython.readthedocs.io/en/stable/interactive/magics.html?highlight=matplotlib#magic-matplotlib>`_
    for details.

.. ipython:: python

    from bluesky.plan_tools import plot_raster_path
    from bluesky.examples import motor1, motor2, det
    from bluesky.plans import outer_product_scan
    import matplotlib.pyplot as plt
    plan = outer_product_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, True)
    @savefig plot-raster-path-1.png
    plot_raster_path(plan, 'motor1', 'motor2', probe_size=.3)

Combining Plans
---------------

To simply chain plans together, use :func:`pchain` to make one long plan.

.. code-block:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, sleep, pchain

    RE(pchain(scan([det], motor, 1, 5, 3),
              sleep(1),
              scan([det], motor, 5, 10, 2)))

.. warning::

    Do not combine plans by calling the RunEngine more than once.

    .. code-block:: python

        # Don't do this.
        RE(plan1()); RE(plan2())

        # And also don't do this.
        def bad_idea():
            RE(plan1())
            RE(plan2())

    In the event of an error or interruptions, the RunEngine can do more to
    recover if it maintains control. In the bad example above, it loses control
    between completing ``plan1`` and beginning ``plan2``.
    
    Instead, use :func:`pchain` or ``yield from`` (see below) to make one long
    plan.

What if want to ``print`` or do other activities between executing the plans?
There is another way to combine plans to accomodate this.

.. code-block:: python

    def master_plan():
        # Scan and read detectors 1 and 2.
        yield from scan([det1, det2], motor, 1, 5, 10)
        print('Now plan1 is finished. Moving on to plan2.')
        # Scan again and just read detector 1.
        yield from relative_scan([det1], motor, 5, 10, 10)

    RE(master_plan())

The plan can employ control flow (``if`` blocks, ``for`` loops, etc.) and the
full power of the Python language. More examples follow.

An Aside on ``yield`` and ``yield from``
----------------------------------------

This is a very brief primer on the Python syntax ``yield`` and ``yield from``.

A Python *function* returns once:

.. ipython:: python

    def f():
        return 1

    f()

A Python *generator* is like a function with multiple exit points. Calling a
generator produces an *iterator* that yields one value at a time. After
each ``yield`` statement, its execution is suspended.

.. ipython:: python

    def f():
        yield 1
        yield 2

We can exhaust the generator (i.e., get all its values) by calling ``list()``.

.. ipython:: python

    list(f())

We can get one value at a time by calling ``next()``

.. ipython:: python

    it = f()
    next(it)
    next(it)

or by looping through the values.

.. ipython:: python

    for val in f():
        print(val)

To examine what is happening when, we can add prints.

.. ipython:: python

    def f():
        print("before 1")
        yield 1
        print("before 2")
        yield 2

.. ipython:: python

    it = f()
    next(it)
    next(it)

Notice that execution is suspended after the first yield statement. The
second ``print`` is not run until we resume execution by requesting a second
value. This is a useful feature of generators: they can express "lazy"
execution.

Generators can delegate to other generators using ``yield from``. This is
syntax we commonly use to combine plans.

.. ipython:: python

    def double_f():
        yield from f()
        yield from f()

.. ipython:: python

    list(double_f())

Built-in Plans
--------------

A variety of pre-assembled plans are provided. Like sandwiches on a deli menu,
you can use our pre-assembled plans or assembled your own from the same
ingredients, catalogued in :ref:`stub_plans` below.

Notice that their names are links. Follow the links for usage details and more
examples.

.. _preassembled_plans:

Pre-assembled Plans
+++++++++++++++++++

Time series ("count")
^^^^^^^^^^^^^^^^^^^^^

Example:

.. code-block:: python

    from bluesky.examples import det
    from bluesky.plans import count

    # a single reading of the detector 'det'
    RE(count([det]))

    # five consecutive readings
    RE(count([det], num=5))

    # five sequential readings separated by a 1-second delay
    RE(count([det], num=5, delay=1))

    # a variable delay
    RE(count([det], num=5, delay=[1, 2, 3, 4])

    # Take readings forever, until interrupted (e.g., with Ctrl+C)
    RE(count([det], num=None))

.. autosummary::
   :toctree:
   :nosignatures:

   count

Scans over one dimesion
^^^^^^^^^^^^^^^^^^^^^^^

The "dimension" might be a physical motor position, a temperature, or a
pseudo-axis. It's all the same to the plans. Examples:

.. code-block:: python

    from bluesky.examples import det, motor
    from bluesky.plans import scan 

    # scan a motor from 1 to 5, taking 5 equally-spaced readings of 'det'
    RE(scan([det], motor, 1, 5, 5))

    # scan a motor from 1 to 5 *relative to its current position*
    RE(relative_scan([det], motor, 1, 5, 5))

    # scan a motor through a list of user-specified positions
    RE(list_scan([det], motor, [1, 1, 2, 3, 5, 8]))

.. autosummary::
   :toctree:
   :nosignatures:

   scan
   relative_scan
   list_scan
   relative_list_scan
   log_scan
   relative_log_scan

Multi-dimensional scans
^^^^^^^^^^^^^^^^^^^^^^^

Again, the "dimesions" may be a mixture of physical positions, temperatures, or
pseudo-axes.

We introduce jargon for two different kinds of a multi-motor scan: the case
whether the motors move together in a joint trajectory ("inner product scan")
and the case where they move separately, exploring every combination ("outer
product scan"). Mixtures of these are also supported.

.. code-block:: python

    from bluesky.examples import det, motor1, motor2, motor3

    # Inner product: move motors together.
    # Move motor1 from 1-5 while moving motor2 from 10-50 -- both in 5 steps.
    RE(inner_product_scan([det], 5, motor1, 1, 5, motor2, 10, 50))

    # Outer product: move motors in a mesh.
    # Move motor1 from 1-5 in 3 steps and motor2 from 10-50 in 5 steps.
    RE(outer_product_scan([det], motor1, 1, 3, 3, motor2, 10, 50, 5, False))

The final parameter designates whether motor2 should "snake" back and forth
along motor1's trajectory (``True``) or retread its positions in the same
direction each time (``False``).

Both :func:`inner_product_scan` and :func:`outer_product_scan` support an
unlimited number of motors/dimensions.

The general case, moving some motors together in an "inner product" against
another (or motors) in an "outer product" can be addressed using a ``cycler``.
Notice what happens when we add or multiply this objects.

.. ipython:: python

    from cycler import cycler
    from bluesky.examples import motor1, motor2, motor3

    traj1 = cycler(motor1, [1, 2, 3])
    traj2 = cycler(motor2, [10, 20, 30])
    list(traj1 + traj2)  # "inner product"
    traj3 = cycler(motor3, [100, 200, 300])
    list((traj1 + traj2) * traj3)  # "outer product" with traj3

For more on cycler, we refer you to the
`cycler documentation <http://matplotlib.org/cycler/>`_. To build a plan
incorporating these trajectories, use :func:`scan_nd`.

.. code-block:: python

    RE(scan_nd((traj1 + traj2) * traj3))

.. autosummary::
   :toctree:
   :nosignatures:

   inner_product_scan
   outer_product_scan
   relative_inner_product_scan
   relative_outer_product_scan
   scan_nd

Spiral trajectories
^^^^^^^^^^^^^^^^^^^

Two-dimensional scans that trace out spiral trajectories:

.. autosummary::
   :toctree:
   :nosignatures:

   spiral
   spiral_fermat
   relative_spiral
   relative_spiral_fermat

Adaptive scans
^^^^^^^^^^^^^^

Scans with adaptive step sizes:

.. autosummary::
   :toctree:
   :nosignatures:

   adaptive_scan
   relative_adaptive_scan

Misc.
^^^^^

.. autosummary::
   :toctree:
   :nosignatures:

   tweak
   fly

.. _stub_plans:

Stub Plans (ingredients for remixing)
+++++++++++++++++++++++++++++++++++++

.. autosummary::
   :nosignatures:
   :toctree:

    abs_set
    checkpoint
    clear_checkpoint
    close_run
    collect
    configure
    create
    deferred_pause
    kickoff
    monitor
    null
    one_1d_step
    one_nd_step
    open_run
    pause
    read
    rel_set
    save
    sleep
    stage
    subscribe
    trigger
    trigger_and_read
    unmonitor
    unstage
    unsubscribe
    wait
    wait_for

We also have a number of wrapper functions, decorators, and utility functions
that make building these easier. Examples and API documentation are in later
sections, below.

Simple Custom Plans
-------------------

Loops
+++++

Produce several runs, changing a parmeter each time.

.. code-block:: python

    def master_plan():
        "Run a plan several times, changing the step size each time."
        for num in range(5, 10):
            # With each iteration, take more densely-spaced readings.
            yield from scan([det1, det2], motor, 1, 5, num)

Execute the sample plan, looping through different samples. Change the plan
parameters depending on the sample.

.. code-block:: python

    sample_list = ['a', 'b', 'c']
    sample_ranges = {'a': {'start': -5, 'stop': -1},
                     'b': {'start': -1, 'stop': 1},
                     'c': {'start': 1, 'stop': 5}}

    def sample_plan(sample_list):
        for sample in sample_list:
            yield from abs_set(sample_plate, sample)
            s_range = sample_ranges[sample]
            md = {'sample': sample}
            yield from scan(motor, num=10, md=md, **s_range)

.. _customizing_metadata:

Customizing metadata
++++++++++++++++++++

Metadata can be loaded from a persistent file, specified by the user
interactively at execution time, or incorporated in a plan.

All of the pre-assembled plans also accept an ``md`` ("metadata") argument,
which makes it easy for a user-defined plan to pass in extra metadata.

.. code-block:: python

    def master_plan():
        # ... insert code here to close shutter ...
        yield from bp.count([det], md={'is_dark_frame': True})
        # ... insert code here to open shutter ...
        yield from bp.count([det], md={'is_dark_frame': False})

By default, the :func:`count` plan records the ``plan_name`` count. To customize
the ``plan_name`` --- say, to differentiate separate *reasons* running a count
--- you can override the metadata.

.. code-block:: python

    def calib_count(dets, num=3):
        md = {'plan_name': 'calib_count'}
        yield from count(dets, num=num, md=md)

To enable users to pass in metadata that combines with and potentially
overrides the hard-coded metadata, use the following pattern:

.. code-block:: python

    from collections import ChainMap

    def calib_count(dets, num=3, *, md=None):
        if md is None:
            md = {}
        md = ChainMap(md, 
                      {'plan_name': 'calib_count'})
        yield from count(dets, num=num, md=md)

For example, if the plan is called with the arguments:

.. code-block:: python

    calib_count([det], md={'plan_name': 'watermelon'})

then ``'watermelon'`` will override ``'calib_count'`` as the recorded plan
name.

.. note::

    The built-in Python data structure ``ChainMap`` is a sequence of
    dictionaries (a "chain of mappings"). It gives prioity to a the first
    mapping that defines a given key.
    
    .. ipython:: python :suppress:

        from collections import ChainMap

    .. ipython:: python
    
        m = ChainMap({'a': 1}, {'a': 2, 'b': 3})
        m['a']
        m['b']

    Thus, ``a=1`` takes precedence of ``a=2``. We use it to give user-provided
    metadata precedence over a plan's hard-coded metadata in the event of a
    key collision.

    See the `relevant section of the Python documentation <https://docs.python.org/3/library/collections.html#collections.ChainMap>`_
    for more.

.. _planned_pauses:

Planned Pauses
++++++++++++++

Pausing is typically done interactively (Ctrl+C) but it can also be
incorporated into a plan. The plan can pause the RunEngine, requiring the user
to type ``RE.resume()`` to continue or ``RE.stop()`` to clean up and stop.

Pauses can be interspersed using :func:`chain`. Demo:

.. ipython:: python

    from bluesky.plans import pchain, count, pause
    from bluesky.examples import det
    RE(pchain(count([det]), pause(), count([det])))
    RE.state  # optional -- just doing this to show that we are paused
    RE.resume()  # or, alternatively, RE.stop()

Or pauses can be incorporated in a plan like so:

.. code-block:: python

    from bluesky.plans import pause, checkpoint

    def pausing_plan():
        while True:
            yield from some_plan(...)
            print("Type RE.resume() to go again or RE.stop() to stop.")
            yield from checkpoint()  # marking where to resume from
            yield from pause()

.. _preprocessors:

Plan Preprocessors
------------------

These "preprocessors" take in a plan and modify its contents on the fly.  For
example, :func:`relative_set_wrapper` rewrites all positions to be relative to
the initial position.

.. code-block:: python

    def relative_scan(detectors, motor, start, stop, num):
        absolute = scan(detectors, motor, start, stop, num)
        relative = relative_set_wrapper(absolute, [motor])
        yield from relative

This is a subtle but remarkably powerful feature.

Wrappers like :func:`relative_set_wrapper` operate on a generator *instance*,
like ``scan(...)``. There are corresponding decorator functions like
``relative_set_decorator`` that operate on a generator
*function* itself, like :func:`scan`.

.. code-block:: python

    # Using a decorator to modify a generator function
    def relative_scan(detectors, motor, start, stop, num):

        @relative_set_decorator([motor])  # unfamiliar syntax? -- see box below
        def inner_relative_scan():
            yield from scan(detectors, motor, start, stop, num)

        yield from inner_relative_scan()

Incidentally, the name ``inner_relative_scan`` is just an internal variable,
so why did we choose such a verbose name? Why not just name it ``f``? That
would work, of course, but using a descriptive name can make debugging easier.
When navigating gnarly, deeply nested tracebacks, it helps if internal variables
have clear names.

.. note::

    The decorator syntax --- the ``@`` --- is a succinct way of passing a
    function to another function.

    This:

    .. code-block:: python

        @g
        def f(...):
            pass

        f(...)

    is equivalent to

    .. code-block:: python

        g(f)(...)

Built-in Preprocessors
++++++++++++++++++++++

Each of the following functions, named ``<something>_wrapper``, operates on
a generator instance. There are corresponding functions named
``<something_decorator>`` that operate on a generator function.

.. autosummary::
   :nosignatures:
   :toctree:

    baseline_wrapper
    finalize_wrapper
    fly_during_wrapper
    inject_md_wrapper
    lazily_stage_wrapper
    monitor_during_wrapper
    relative_set_wrapper
    reset_positions_wrapper
    run_wrapper
    stage_wrapper
    subs_wrapper

Custom Preprocessors
++++++++++++++++++++

The preprocessors are implemented using :func:`msg_mutator` (for altering
messages in place) and :func:`plan_mutator` (for inserting
messages into the plan or removing messages).

It's easiest to learn this by example, studying the implementations of the built-in
processors (catalogued above) in the
`the source of the plans module <https://github.com/NSLS-II/bluesky/blob/master/bluesky/plans.py>`_.

How Plans Handle Exceptions
---------------------------

If an exception is raised, the RunEngine gives the plan the opportunity to
catch the exception and either handle it or merely yield some "clean up"
messsages before re-raising the exception and killing plan execution.

.. code-block:: python

    def plan_with_cleanup():
        try:
            yield from main_plan()
        except Exception:
            # Catch the exception long enough to clean up.
            yield from cleanup_plan()
            raise  # Re-raise the exception.

The :func:`finalize_wrapper` preprocessor provides a succinct way of applying
this pattern.

.. code-block:: python

    def plan_with_cleanup():
        yield from finalize_wrapper(main_plan(), cleanup_plan())

The exception in question may originate from the plan itself or from the
RunEngine when it attempts to execute a given command.

Advanced Custom Plans
---------------------

The ``per_step`` hook
+++++++++++++++++++++

The one-dimensional and multi-dimensional plans are composed (1) setup,
(2) a loop over a plan to perform at each position, (3) cleanup.

We provide a hook for customizing step (2). This enables you to write a
variation of an existing plan without starting from scratch.

For one-dimensional plans, the default inner loop is:

.. code-block:: python

    from bluesky.plans import checkpoint, abs_set, trigger_and_read

    def one_1d_step(detectors, motor, step):
        """
        Inner loop of a 1D step scan

        This is the default function for ``per_step`` param in 1D plans.
        """
        yield from checkpoint()
        yield from abs_set(motor, step, wait=True)
        return (yield from trigger_and_read(list(detectors) + [motor]))

Some user-defined function, ``custom_step``, with the same signature can be
used in its place:

.. code-block:: python

    scan([det], motor, 1, 5, 5, per_step=custom_step)

For convenience, this could be wrapped into the definition of a new plan:

.. code-block:: python

    def custom_scan(detectors, motor, start, stop, step, *, md=None):
        yield from scan([det], motor, start, stop, step, md=md
                        per_step=custom_step)

For multi-dimensional plans, the default inner loop is:

.. code-block:: python

    from bluesky.utils import short_uid
    from bluesky.plans import checkpoint, abs_set, wait, trigger_and_read

    def one_nd_step(detectors, step, pos_cache):
        """
        Inner loop of an N-dimensional step scan

        This is the default function for ``per_step`` param in ND plans.

        Parameters
        ----------
        detectors : iterable
            devices to read
        step : dict
            mapping motors to positions in this step
        pos_cache : dict
            mapping motors to their last-set positions
        """
        def move():
            yield from checkpoint()
            grp = short_uid('set')
            for motor, pos in step.items():
                if pos == pos_cache[motor]:
                    # This step does not move this motor.
                    continue
                yield from abs_set(motor, pos, group=grp)
                pos_cache[motor] = pos
            yield from wait(group=grp)

        motors = step.keys()
        yield from move()
        yield from trigger_and_read(list(detectors) + list(motors))

Likewise, a custom function with the same signature may be passed into the
``per_step`` argument of any of the multi-dimensional plans.

Reconstructing ``count`` from scratch
+++++++++++++++++++++++++++++++++++++

In this section we will build a custom plan out of the stub plans above.
To make clear which of the variables below come from ``bluesky.plans`` we will
import the plans module like so.

.. code-block:: python

    import bluesky.plans as bp

What we referred to as :func:`count`, :func:`scan`, and so on above will in this
section be referred to as ``bp.count``, ``bp.scan``, etc.

.. code-block:: python

    from bluesky.examples import det1, det2
    import bluesky.plans as bp

The basic usage of the :func:`count` plan generates one "run" (i.e., dataset)
with one "event" (i.e., one bundle of readings from the detectors, one row in
a table of the data).

.. code-block:: python

    dets = [det1, det2]
    RE(bp.count(dets))

The ``num`` argument enables multiple events (rows) in one run.

.. code-block:: python

    # one 'run' with three 'events'
    RE(bp.count(dets, num=3))

If we didn't provide a num option, how could you make one yourself?

A tempting --- but wrong! --- possibility is to loop over calls to
``RE(bp.count(dets))``.

.. code-block:: python

    # Don't do this!
    for _ in range(3):
        RE(bp.count(dets))

As stated above, this ruins error-recovery and interruption recovery. It's much
better to do the loop inside a custom plan, which we'll dub ``multicount``.

.. code-block:: python

    def multicount(dets):
        for _ in range(3):
            yield from bp.count(dets)

    RE(multicount(dets))

In fact, instead of hard-coding 3, we could make it an argument configurable
by the user. We can make the configuration optional by providing 3 as a
default.

.. code-block:: python

    def multicount(dets, num=3):
        for _ in range(num):
            yield from bp.count(dets)

But this still creates three runs --- three datasets --- for what we'd rather
think of as three events (rows) in one run. To fix that, we'll have to dive
deeper, re-implementing :func:`count` from scratch.

.. code-block:: python

    def multicount(dets, num=3, *, md=None):

        @bp.stage_decorator(dets)
        @bp.run_decorator(md=md)
        def inner_multicount():
            for _ in range(num):
                yield from bp.trigger_and_read(dets)

        yield from inner_multicount()


Starting from the middle and explaining outward:

* The :func:`trigger_and_read` plan generates an "event" (a row of data) from
  reading ``dets``. This happens inside of a loop, ``num`` times.
* The ``run_decorator`` preprocessor designates the scope of one dataset.
* The ``stage_decorator`` preprocessor addresses some hardware details. It
  primes the hardware for data collection.  For some devices, this has no
  effect at all. But for others, it ensures that the device is put into a
  ready, triggerable state and then restored to standby at the end of the plan.

Plans with adaptive logic
+++++++++++++++++++++++++

TO DO

Asynchronous data streams
+++++++++++++++++++++++++

TO DO

Plan Utilities
--------------

These are useful utilities for defining custom plans and plan preprocessors.

.. autosummary::
   :toctree:
   :nosignatures:

    pchain
    msg_mutator
    plan_mutator
    single_gen
    broadcast_msg
    repeater
    caching_repeater
    make_decorator

Object-Oriented-Style Plans
---------------------------

These provide an alternative interface to plans that is convenient for some
workflows. The plan becomes a reusable object: unlike a generator instance, it
is not "exhausted" after the first use.

.. code-block:: python

    from bluesky.plans import Scan
    from bluesky.examples import motor, det, det3
    plan = Scan([det], motor, 1, 3, 3)  # a "reusable" object-oriented plan

When it is passed to the RunEngine (in general, when it is iterated over) it
re-instantiates a generator automatically using the same parameters.

.. code-block:: python

    RE(plan)  # This is the same as before...
    RE(plan)  # ...but this would not work with generators, only the OO plans.

For each parameter there is an attribute that can be adjusted interactively.

.. code-block:: python

    plan.num = 4  # change number of data points from 10 to 4
    plan.detectors.append(det3)  # add another detector

The ``set`` method is a convenient way to update multiple parameters at once.

.. code-block:: python

    plan.set(start=20, stop=25)

Built-in Object-Oriented Plans
++++++++++++++++++++++++++++++

For each of the "pre-assembled" plans catalogued above, bluesky ships an
object-oriented counterpart.

.. autosummary::
   :nosignatures:
   :toctree:

    Count
    Scan
    RelativeScan
    ListScan
    RelativeListScan
    LogScan
    RelativeLogScan
    InnerProductScan
    OuterProductScan
    RelativeInnerProductScan
    RelativeOuterProductScan
    ScanND
    SpiralScan
    SpiralFermatScan
    RelativeSpiralScan
    RelativeSpiralFermatScan
    AdaptiveScan
    RelativeAdaptiveScan
    Tweak

Custom Object-Oriented Plans
++++++++++++++++++++++++++++

To define a custom object-oriented Plan, follow this pattern. Here we define
:class:`Scan`, the object-oriented counterpart to :func:`scan`.

.. code-block:: python

    from bluesky.plans import Plan

    class Scan(Plan):
        __doc__ = scan.__doc__  # mirror the docstring of 'scan'

        def __init__(self, detectors, motor, start, stop, num, *, md=None):
            self.detectors = detectors
            self.motor = motor
            self.start = start
            self.stop = stop
            self.num = num
            self.md = md

        def _gen(self):
            return scan(self.detectors, self.motor, self.start, self.stop,
                        self.num, md=self.md)


This ``__init__`` method contains a lot of boilerplate code, assigning an
attribute for each argument. For cases like this where a plan takes zero or
more required arguments plus ``md``, the ``Plan`` class provides a shortcut
using metaclass magic.

Optionally, the definition of ``__init__`` can be entirely removed and replaced
by the line

.. code-block:: python

    _fields = ['detectors', 'motor', 'start', 'stop', 'num']

which ``Plan`` uses to auto-generate an ``__init__`` at class definition time.
If that is a little too "magical" for your taste, feel free to skip it and just
write out the ``__init__`` method, as we did in the example above.

SPEC-like API with Global State
-------------------------------

Some scientists are familiar with `SPEC <http://www.certif.com/spec.html>`_,
a domain-specific language for hardware control. It is possible to imitate the
SPEC workflow on top of bluesky. Of course, we still adhere to the Python
syntax so that we can employ the full power of the general-purpose Python
language.

The "SPEC-like" plans are extensions of the pre-assembled plans, reusing the
same internal logic under a different interface.

Built-in SPEC-like plans
++++++++++++++++++++++++

.. currentmodule:: bluesky

.. autosummary::
   :toctree:
   :nosignatures:

    spec_api.ct
    spec_api.ascan
    spec_api.dscan
    spec_api.mesh
    spec_api.a2scan
    spec_api.d2scan
    spec_api.a3scan
    spec_api.d3scan
    spec_api.spiral
    spec_api.aspiral
    spec_api.fermat
    spec_api.afermat
    spec_api.tw
    spec_api.th2th

Differences from non-SPEC-like plans
++++++++++++++++++++++++++++++++++++

To see the differences, compare the SPEC-like plan ``ascan`` its non-SPEC-like
counterpart :func:`scan`.

.. code-block:: python

    # non-SPEC-like
    RE(scan([det], motor, 1, 5, 5))

    # SPEC-like
    gs.DETS = [det]
    RE(ascan(motor, 1, 5, 4))

* **Global list of detectors.** :func:`scan` expects a list of detectors --- e.g.,
  ``[det]`` --- as its first argument. ``ascan`` obtains the detector list
  implicitly by checking the current value of ``gs.DETS``.
* **Globally configured subscriptions.** ``ascan`` bakes in subscriptions to
  ``LiveTable`` and ``LivePlot`` by default. These defaults are configurable
  --- see below.
* **Arguments' names and ordering.** The signatures match those in the SPEC
  manual. In some cases they are different from the signature of their non-SPEC
  counterparts, which adhere more closely to idiomatic scientific Python.
  What :func:`scan` calls "start" and "stop" ``ascan`` calls "start" and "finish".
* **Count strides, not points.** Following the convention in SPEC, the
  SPEC-like plans expect the number of "intervals" (strides) N, leading to N +
  1 points. In all other parts of bluesky, we adhere to the Python/scipy
  convention, expecting the user to input the number of points. To avoid
  confusion, the argument names are different: non-SPEC-like plans have a
  ``num`` argument; SPEC-like plans have ``intervals`` instead.

Global state
++++++++++++

Bluesky ships ``bluesky.global_state.gs``, a singleton ``GlobalState`` object
that serves as a stash for configuration shared by the SPEC-like plans.

In IPython, type ``gs??`` for an exhuastive list of its attributes. Highlights:

======================= =======
Attribute               Purpose
======================= =======
``gs.DETS``             the list of detectors
``gs.TABLE_COLS``       list of field names to include in ``LiveTable``
``gs.PLOT_Y``           field name to plot as y axis of ``LivePlot``
``gs.OVERPLOT``         True or False; whether to replot to same axes
``gs.FLYERS``           "flyable" devices to fly-scan during all plans
``gs.BASELINE_DEVICES`` devices to read once before and after all plans
======================= =======

Subscription Factories
++++++++++++++++++++++

Another important attribute of global state is ``gs.SUB_FACTORIES``, which
requires some explaining.  This feature is related to bluesky's subscriptions
model for processing data.  If you are unfamiliar, you should skim
:ref:`callbacks` before proceeding.

``SUB_FACTORIES`` stands for "subscription factories." Each entry in the
``SUB_FACTORIES`` dictionary maps a ``plan_name`` (e.g., ``'ascan'``) to
functions that return callback functions. These callbacks will be subscribed to
documents generated by that plan. Example:

.. code-block:: python

    from bluesky.global_state import gs
    from bluesky.callbacks import LiveTable
 
    def setup_livetable(*, motors,  gs):
        "Construct a LiveTable callback based on the motors and gs."
        return LiveTable(motors + [gs.PLOT_Y] + gs.TABLE_COLS)

    gs.SUB_FACTORIES['ascan'] = [setup_livetable]

The function can expect as arguments ``gs`` and any metadata generated by the
plan --- in the example above, the list of motors. The function's signature is
inspected automatically, and it is magically passed the correct parameters.

The leading ``*`` in the function signature makes ``motors`` and ``gs``
*required, keyword-only arguments*. Any custom functions must follow this
pattern as well in order for the magic inspection to work properly.

Built-in Subscription Factories
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. currentmodule:: bluesky

.. autosummary::
   :toctree:
   :nosignatures:

    spec_api.setup_plot
    spec_api.setup_ct_plot
    spec_api.setup_livetable
    spec_api.setup_peakstats
    spec_api.setup_liveraster
