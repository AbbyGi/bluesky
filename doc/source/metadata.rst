******************
Recording Metadata
******************

Capturing useful metadata is the main objective of bluesky.

The more information you can provide and what you are doing and why you are
doing it, the more useful bluesky and downstream data search and analysis tools
can be become. To a large extent, bluesky captures metadata automatically, but
there is of course a limit to what it can know about your intentions without
your input.

Ways metadata is provided
=========================

When a RunEngine executes a plan, it combines metadata:

* entered interactively by the user
* provided in the code of the *plan*
* automatically inferred
* specified by the user in a persistent metadata stash

in order of decreasing precedence. In this section we address each item in
detail.

Interactively
-------------

The RunEngine accepts arbitrary extra keyword arguments. They will be
interpreted as metadata. Suppose we are executing any custom-defined plan:

.. code-block:: python

    RE(plan(), sample_id='A', purpose='calibration', operator='Dan')

The run(s) --- i.e., datasets --- generated by ``plan()`` will all include the
custom metadata fields 'sample_id', 'mood', and 'operator'.

Through a plan
--------------

In the previous example, if ``plan`` generates more that one run, all the runs
will get this metadata. For example, this plan generates three different runs.

.. code-block:: python

    from bluesky.plans import count, scan
    from bluesky.examples det1, det2, motor  # simulated detectors, motor

    def plan():
        yield from count([det])
        yield from scan([det], motor, 1, 5, 5)
        yield from count([det])

To be more selectively, pass the metadata into the plan instead. Every
:ref:`built-in pre-assembled plan <preassembled_plans>` accepts a parameter
``md``, which you can use to inject metadata that applies only to that plan.

.. code-block:: python

    def plan():
        yield from count([det], md={purpose: 'calib'})
        yield from scan([det], motor, 1, 5, 5, md={'purpose': 'good data'})
        yield from count([det], md={'purpose': 'sanity check'})

The metadata passed into ``RE`` is combined with the metadata passed in to each
plan. Thus, each run's metadata will include sample_id, operator, and purpose.

In the event of a key collision, ``RE`` keywords takes precedence. So

.. code-block:: python

    RE(plan(), purpose='test')

would override the individual 'purpose' metadata from the plan, marking all as
purpose=test.

For more on injecting metadata via plans, refer to :ref:`customizing_metadata`.

Automatically
-------------

For each run, the RunEngine automatically records:

* 'time' --- In this context, the start time. (Other times are also recorded.)
* 'uid' --- a globally unique ID for this run
* 'plan_name' --- the function or class name of ``plan`` (e.g., 'count')
* 'plan_type'--- e.g., the Python type of ``plan`` (e.g., 'generator')

The last two can be overridden by any of the methods above. The first two are
not user-overridable.

.. note::

    The RunEngine gets 'plan_name' and 'plan_type' from ``plan`` as follows:

    .. code-block:: python

        plan_name = type(plan).__name__
        plan_type = getattr(plan, '__name__', '')

    These can be more or less informative depending on what ``plan`` is. They
    are just heurisitcs to provide *some* information by default if the plan
    itself and the user do not provide it.

Persistently
------------

To set a field of metadata to persist for future runs, add it to ``RE.md``.
This metadata takes lowest precedence in the event of key collisions.

.. code-block:: python

    RE.md['proposal_id'] = 123456
    RE.md['project'] = 'flying cars'
    RE.md['dimensions'] = (5, 3, 10)

Each time a plan is executed, the current contents of ``RE.md`` are copied into
the metadata for all runs generated by the plan. 

``RE.md`` is a dictionary, and all the normal dictionary operations apply:

.. code-block:: python

    RE.md  # inspect contents
    del RE.md['project']   # delete a key

.. warning::

    The ``scan_id``, an integer that the RunEngine automatically
    increments at the beginnging of each scan, is stored in
    ``RE.md['scan_id']``.  Clearing all keys, like so:

    .. code-block:: python

        RE.md.clear()  # clear *all* keys

    will reset the ``scan_id``. The next time a plan is executed, the
    RunEngine will start with a ``scan_id`` of 1 and set

    .. code-block:: python

        RE.md['scan_id'] = 1

    Some readers may prefer to reset the scan ID to 1 at the beginning of a new
    experiment; others way wish to maintain a single unbroken sequence of scan
    IDs forever.

    From a technical standpoint, it is fine to have duplicate scan IDs. All
    runs also have randomly-generated 'uid' ("unique ID") which is globally
    unique forever.

Persistence Between Sessions
============================

We provide way to persist the contents of the metadata stash ``RE.md`` between
sessions (e.g., exiting and re-opening IPython).

In general, the ``RE.md`` attribute may be an ordinary Python dictionary or
anything that supports the dictionary interface. To persist metadata between
sessions, bluesky uses ``HistoryDict`` --- a Python dictionary backed by a
sqlite database file. Any changes made to ``RE.md`` are synced to the file
before IPython exits.

The easiest way to create a ``HistoryDict`` to use the convenience function,
``get_history``. It searches for a pre-existing history file in one of several
standard locations and, if it doesn't find one, it creates a new one.  (See the
``get_history`` documentation below for details.)

.. code-block:: python

    from bluesky.utils import get_history
    RE = RunEngine(get_history())

Alternatively, create a ``HistoryDict`` manually anywhere you please:

.. code-block:: python

    from historydict import HistoryDict
    h = HistoryDict('your/path/here')
    RE = RunEngine(h)

.. autofunction:: bluesky.utils.get_history

See also the
`historydict documentation <https://github.com/Nikea/historydict#historydict>`_.

Allowed Data Types
==================

Custom metadata keywords can be mapped to:

* strings --- e.g., ``task='calibration'``
* numbers --- e.g., ``attempt=5``
* lists or tuples --- e.g., ``dimensions=[1, 3]``
* (nested) dictionaries --- e.g., ``dimensions={'width': 1, 'height': 3}``


Special Fields
==============

Arbitrary custom fields are allowed --- you can invent any names that are
useful to you.

But certain fields are given special significance by bluesky's document model,
and are either disallowed are required to be a certain type.

The fields:

* **owner**
* **group**
* **project**
  
are optional but, to facilite searchability, if they are not blank they must be
strings. A non-string, like ``owner=5`` will produce an error that will
interrupt scan execution immediately after it starts.

Similarly, the keyword **sample** has special significance. It must be either a
string or a dictionary.

The **scan_id** field is expected to be an integer, and it is automatically
incremented between runs. If a scan_id is not provided by the user or stashed
in the persistent metadata from the previous run, it defaults to 1.

The fields:

* **uid**
* **time**

are reserved by the document model and cannot be set by the user.

Required Fields
===============

In current versions of bluesky, **no fields are universally required**. It is
possible specify your own required fields in local configuration. See
:ref:`md_validator`.

In versions v0.4.3 and below, the keys ``owner``, ``group``, and
``beamline_id`` were required.

.. _md_validator:

Metadata Validator
==================

Additional, customized metadata validation can be added to the RunEngine.
For example, to ensure that a run will not be executed unless the parameter
'sample_number' is specified, define a function that accepts a dictionary
argument and raises if 'sample_number' is not found.

.. code-block:: python

    def ensure_sample_number(md):
        if 'sample_number' not in md:
            raise ValueError("You forgot the sample number.")

Apply this function by setting

.. code-block:: python

    RE.md_validator = ensure_sample_number

The function will be executed immediately before each new run in opened.
