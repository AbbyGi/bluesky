Multi-Run Plans
===============

This section is a brief tutorial on multi-run plans (introduced in Bluesky v1.6.0).
A traditional single-run plan contains a set of instructions for running only one scan,
which is assigned scan ID and UID. When multi-run plan is executed by Run Engine, multiple
scans can be performed as part of a single plan. Data from each scan can be independently
displayed and saved to the database via Databroker. The prior versions of Bluesky supported
sequential execution of multiple scans within the plan. Starting from Bluesky v1.6.0, plans
may include nested scans, i.e. the scans that can be interrupted, another scan executed and then the
interrupted scan resumed and completed. Interruption can be initiated by the scan itself
(simply by calling another scan from within the currently running scan) or externally (e.g. by triggering
a suspender). The tutorial include brief explanation of the new Bluesky features that facilitate
support of multi-run plans and examples that demonstrate implementation of the plans with
sequential, nested and recursive calling of scans.

Definition of a 'Scan'
----------------------

We define a scan as a block of code which generates a sequence of messages that control
the data acquisition experiment. The scan starts with `open_run` and ends with `close_run` messages.
Each scan is assigned distinct Scan ID and UID and produces a separate
set of documents, including 'start' and 'stop' documents that are emitted and the processed by
callbacks (such as BestEffortCallback) and saved to the database via Databroker (if enabled).

In the plan, the scan may be defined by explicitely enclosing the code in `bps.open_run()` and
`bps.close_run()` stubs:

.. code-block:: python

    # Using 'bps.open_run()' and 'bps.close_run()' stabs to define a scan

    import bluesky.plan_stubs as bps
    from bluesky import RunEngine

    RE = RunEngine({})

    def sample_plan():
        ...
        bps.open_run(md={})  # 'md' - metadata to be added to the 'start' document
        ...
        < code that controls execution of the scan >
        ...
        bps.close_run()

    RE(sample_plan())

or using `@bpp.run_decorator`, which inserts `open_run` and `close_run` control messages
before and after the sequnce generated by the enclosed code:

.. code-block:: python

    # Using 'bpp.run_decorator' to define a scan

    import bluesky.preprocessors as bpp
    from bluesky import RunEngine

    RE = RunEngine({})

    @bpp.run_decorator(md={})  # 'md' - metadata to be added to the 'start' document
    def sample_plan():
        ...
        < code that controls execution of the scan >
        ...

    RE(sample_plan())

The rules for basic Bluesky plans require that the currently running scan must be closed before
the next scan is opened, therefore the following code works:

.. code-block:: python

    # This code works, since the first run is closed before the second one is opened

    import bluesky.plan_stubs as bps
    from bluesky import RunEngine

    RE = RunEngine({})

    def sample_plan():
        bps.open_run(md={})
        < code that controls execution of the scan >
        bps.close_run()  # Closing the first run (scan)
        bps.open_run(md={})  # Opening the second run (scan)
        < code that controls execution of the scan >
        bps.close_run()

    RE(sample_plan())

but the following code fails:

.. code-block:: python

    # This code fails, since the second run is opened before the first run is closed

    import bluesky.plan_stubs as bps
    from bluesky import RunEngine

    RE = RunEngine({})

    def sample_plan():
        bps.open_run(md={})  # Starting the first run
        < code that controls execution of the scan >
        bps.open_run(md={})  # Starting the second scan before the first one is closed
        < code that controls execution of the scan >
        bps.close_run()
        bps.close_run()

    RE(sample_plan())


Note, that the preassembled plans, such as `bluesky.plans.count` or `bluesky.plans.list_scan`,
are complete single-run plans, enclosed in `open_run` and `close_run` messages, therefore
the following code fails as well:

.. code-block:: python

    # This code fails while attempting to start a preassembled plan from an open run

    import bluesky.plan_stubs as bps
    from bluesky.plans import count
    from bluesky import RunEngine

    RE = RunEngine({})

    def sample_plan():
        bps.open_run(md={})  # Starting the first run
        < code that controls execution of the scan >
        bpp.count(<some arguments>)  # Attempting to run a preassembled plan from an open run
        bps.close_run()

    RE(sample_plan())

While it is unusual to call preassembled plans directly from within a user-defined scan, one may encounter
this situation if a preassembled plan is part of a suspender pre- or post-plan. When the suspender is
triggered, the currently running scan is interrupted (not closed). If pre- or post-plan attempts to open
another run (the new run is called as a nested run, see below), Run Engine fails for the same reason
as in two previous code examples. The new multi-run plan Bluesky features allow to implement nested plans,
as well as include full-featured scans in pre- and post-plans.

Bluesky Features for Support of Multi-run Plans
-----------------------------------------------

In order to handle simultaneously opened runs within a plan, Run Engine is looking at the run key attribute
of each control message to decide which scan is currently being executed. The default value for the run key
is `None`, but could be manually set in the plan for any block of code which define a scan. Run key
may be of any type, but it is **strongly** recommended that manually assigned run keys are
human-readable informative strings.

The new 'inner' scan can be opened from within the 'outer' scan only if the run keys of the 'inner' and
'outer' scans are different.

The run key is used by Run Engine

* to maintain the state of each run independently from other open runs;

* to include run metadata, such as scan ID and UID, into the emitted documents. (Metadata is then used
  to route the documents to the appropriate callbacks. If documents are saved using Databroker, the metadata
  allows to associate documents with scans and retrieve scan data from the database.)

Run key is assigned to a block of code using `bpp.set_run_key_wrapper` or `@bpp.set_run_key_decorator`:

.. code-block:: python

    import bluesky.preprocessors as bpp
    from bluesky import RunEngine

    # Using decorator
    @bpp.set_run_key_decorator("run_key_example_1")
    @bpp.run_decorator(md={})
    def sample_plan():
        ...
        < code that controls execution of the scan >
        ...

    RE(sample_plan())

    from bluesky.plans import scan
    from ophyd.sim import hw
    det, motor = hw().det, hw().motor

    # Using wrapper
    s = scan([det], motor, -1, 1, 10)
    s_wrapped = bpp.set_run_key_wrapper(s, "run_key_example_2")
    RE(s_wrapped)

The implementations of `@bpp.set_run_key_decorator` and `bpp.set_run_key_wrapper` are
replacing the default value `None` of the attribute `run` in each message generated within
the enclosed block with the user-defined run key.

The `@bpp.set_run_key_decorator` and `bpp.set_run_key_wrapper` are primarily intended
to be applied to a function that contain implementation of a scan, but may be used
with any block of plan code. For example, one may write a plan that simultaneously
opens multiple scans and executes them in parallel by executing groups of messages
with run ids of the open scans. This is currently not recommended and could be attempted
on the developer's own risk.

Plans with Sequential Runs
---------------------------

Sequential call of multiple scans was supported by older versions of Bluesky. There is no need
to use multi-run plan features if scans are not overlapping (the next run is opened after
the previous run is closed), but run keys still may be assigned to all or some scans if needed.

In the following example, two preassembled plans are called in sequence. Run Engine is subscribed to
a single instance of BestEffortCallback, which is set up at the opening of each run.

.. code-block:: python

    # Example: consecutive execution of single-run plans

    from bluesky import RunEngine
    from bluesky.callbacks.best_effort import BestEffortCallback
    from databroker import Broker
    from bluesky.plans import scan, rel_scan

    from ophyd.sim import hw
    hw = hw()

    RE = RunEngine({})

    db = Broker.named("temp")
    RE.subscribe(db.insert)

    bec = BestEffortCallback()
    RE.subscribe(bec)

    def plan_sequential_runs(npts):
        # Single-run plans may be called consecutively. No special handling is required
        #   as long as the previous scan is closed before the next one is opened
        yield from scan([hw.det1], hw.motor1, -1, 1, npts)
        yield from rel_scan([hw.det1, hw.det2], hw.motor1, -1, 1, npts)

.. ipython:: python
    :suppress:

    %run -m multi_run_plans_sequential

.. ipython:: python

    RE(plan_sequential_runs(10))

Plans with Nested Runs
----------------------

The following example illustrates the use of `@bpp.set_run_key_decorator` to implement two nested scans:
the 'outer' scan interrupts measurements, calls the 'inner' scan and then completes the measurements.
The 'outer' and 'inner' scans are assigned different run ids ('run_1' and 'run_2'). Note that
the `@bpp.set_run_key_decorator` for the 'outer' scan does not overwrite run id of the 'inner' scan,
despite the fact that it is generated inside the enclosed code, since the decorator is designed to replace
the run id attribute of the message only if it has the default value of `None`.

If multiple plans are to be opened simultaneously, each plan needs to be subscribed to its own instance
of callback. Standard RunEngine subscription mechanism does not provide this capability. Instead,
subscription should be performed via `RunRouter`. The code in the following example demonstrates how
to use `BestEffortCallback` to monitor data from multiple nested plans.

.. code-block:: python

    # Example: nested runs

    from bluesky import RunEngine
    from bluesky.callbacks.best_effort import BestEffortCallback
    import bluesky.preprocessors as bpp
    import bluesky.plan_stubs as bps
    from databroker import Broker
    from event_model import RunRouter

    from ophyd.sim import hw
    hw = hw()

    RE = RunEngine({})

    db = Broker.named("temp")
    RE.subscribe(db.insert)

    def factory(name, doc):
        # Documents from each run is routed to an independent
        #   instance of BestEffortCallback
        bec = BestEffortCallback()
        return [bec], []

    rr = RunRouter([factory])
    RE.subscribe(rr)

    @bpp.set_run_key_decorator("run_2")
    @bpp.run_decorator(md={})
    def sim_plan_inner(npts):
        for j in range(npts):
            yield from bps.mov(hw.motor1, j * 0.1 + 1, hw.motor2, j * 0.2 - 2)
            yield from bps.trigger_and_read([hw.motor1, hw.motor2, hw.det2])

    @bpp.set_run_key_decorator("run_1")
    @bpp.run_decorator(md={})
    def sim_plan_outer(npts):
        for j in range(int(npts/2)):
            yield from bps.mov(hw.motor, j * 0.2)
            yield from bps.trigger_and_read([hw.motor, hw.det])

        yield from sim_plan_inner(npts + 1)

        for j in range(int(npts/2), npts):
            yield from bps.mov(hw.motor, j * 0.2)
            yield from bps.trigger_and_read([hw.motor, hw.det])

The output of the plan contains data from two scans with each plan assigned its own ID and UID. The tables
for the scans are printed by two separate instances of `BestEffortCallback`. The data from two tables
is printed in the order of acquisition: the table for the 'inner' scan is printed in the gap of
the 'outer' scan.

.. ipython:: python
    :suppress:

    %run -m multi_run_plans_nested

.. ipython:: python

    RE(sim_plan_outer(10))

The wrapper `bpp.set_run_key_wrapper` can be used instead of the decorator. For example
the run `sim_plan_inner` from the previous example can be rewritten as follows:

.. code-block:: python

    def sim_plan_inner(npts):
        def f():
            for j in range(npts):
                yield from bps.mov(hw.motor1, j * 0.1 + 1, hw.motor2, j * 0.2 - 2)
                yield from bps.trigger_and_read([hw.motor1, hw.motor2, hw.det2])
        f = bpp.run_wrapper(f(), md={})
        return bpp.set_run_key_wrapper(f, "run_2")

Subscription to callbacks via RunRouter provides flexibility to subscribe each run
to its own set of callbacks. In the following example `run_key` is added to the start
document metadata and used to distinguish between two runs in the function factory that
performs callback subscriptions.

.. code-block:: python

    # Example: subscribing runs to individual sets of callbacks

    from bluesky import RunEngine
    from bluesky.callbacks import LiveTable, LivePlot
    import bluesky.preprocessors as bpp
    import bluesky.plan_stubs as bps
    from databroker import Broker
    from event_model import RunRouter

    from ophyd.sim import hw
    hw = hw()

    RE = RunEngine({})

    db = Broker.named("temp")
    RE.subscribe(db.insert)

    def factory(name, doc):
        # Runs may be subscribed to different sets of callbacks. Metadata from start
        #   document may be used to identify, which run is currently being started.
        #   In this example, the run key is explicitely added to the start document
        #   and used to identify runs, but other data can be similarly used.
        cb_list = []
        if doc["run_key"] == "run_1":
            cb_list.append(LiveTable([hw.motor1, hw.det1]))
            cb_list.append(LivePlot('det1', x='motor1'))
        elif doc["run_key"] == "run_2":
            cb_list.append(LiveTable([hw.motor1, hw.motor2, hw.det2]))
        return cb_list, []

    rr = RunRouter([factory])
    RE.subscribe(rr)

    @bpp.set_run_key_decorator("run_2")
    @bpp.run_decorator(md={"run_key": "run_2"})
    def sim_plan_inner(npts):
        for j in range(npts):
            yield from bps.mov(hw.motor1, j * 0.1 + 1, hw.motor2, j * 0.2 - 2)
            yield from bps.trigger_and_read([hw.motor1, hw.motor2, hw.det2])

    @bpp.set_run_key_decorator("run_1")
    @bpp.run_decorator(md={"run_key": "run_1"})
    def sim_plan_outer(npts):
        for j in range(int(npts/2)):
            yield from bps.mov(hw.motor1, j)
            yield from bps.trigger_and_read([hw.motor1, hw.det1])

        yield from sim_plan_inner(npts + 1)

        for j in range(int(npts/2), npts):
            yield from bps.mov(hw.motor1, j)
            yield from bps.trigger_and_read([hw.motor1, hw.det1])

.. ipython:: python
    :suppress:

    %run -m multi_run_plans_select_cb

.. ipython:: python

    RE(sim_plan_outer(10))

In some cases it may be necessary to implement a run that could be interrupted
and a new instance of the same run started. For example, the suspender pre- or post-plan
may implement a complete scan, which may also be interrupted if the suspender is triggered again.
This will cause the pre- or post-plan to be started while it is still open, which is similar
to recursive calling of the scan (from within itself from). Recursive calls are possible if
unique run key is assigned to a scan each time it is started.

The following example illustrates dynamic generation of run keys. The plan has no practical purpose
besides demonstration of the principle. The plan is calling itself recursively multiple times until
the global counter `n_calls` reaches the maximum value of `n_calls_max`. The unique run key is generated
before at each call.

.. code-block:: python

    # Example: recursive runs

    from bluesky import RunEngine
    from bluesky.callbacks.best_effort import BestEffortCallback
    import bluesky.preprocessors as bpp
    import bluesky.plan_stubs as bps
    from databroker import Broker
    from event_model import RunRouter

    from ophyd.sim import hw
    hw = hw()

    RE = RunEngine({})

    db = Broker.named("temp")
    RE.subscribe(db.insert)

    def factory(name, doc):
        # Each run is subscribed to independent instance of BEC
        bec = BestEffortCallback()
        return [bec], []

    rr = RunRouter([factory])
    RE.subscribe(rr)

    # Call counter and the maximum number calls
    n_calls, n_calls_max = 0, 3

    def sim_plan_recursive(npts):
        global n_calls, n_calls_max

        n_calls += 1  # Increment counter
        if n_calls <= n_calls_max:
            # Generate unique key for each run. The key generation algorithm
            #   must only guarantee that execution of the runs that are assigned
            #   the same key will never overlap in time.
            run_key = f"run_key_{n_calls}"

            @bpp.set_run_key_decorator(run_key)
            @bpp.run_decorator(md={})
            def plan(npts):

                for j in range(int(npts/2)):
                    yield from bps.mov(hw.motor1, j * 0.2)
                    yield from bps.trigger_and_read([hw.motor1, hw.det1])

                # Different parameter values may be passed to the recursively called plans
                yield from sim_plan_recursive(npts + 2)

                for j in range(int(npts/2), npts):
                    yield from bps.mov(hw.motor1, j * 0.2)
                    yield from bps.trigger_and_read([hw.motor1, hw.det1])

            yield from plan(npts)

.. ipython:: python
    :suppress:

    %run -m multi_run_plans_recursive

.. ipython:: python

    RE(sim_plan_recursive(4))

The identical result can be achieved by using `bpp.set_run_key_wrapper()`:

.. code-block:: python

    # Call counter and the maximum number calls
    n_calls, n_calls_max = 0, 3

    def sim_plan_recursive(npts):
        global n_calls, n_calls_max

        n_calls += 1  # Increment counter
        if n_calls <= n_calls_max:
            # Generate unique key for each run. The key generation algorithm
            #   must only guarantee that execution of the runs that are assigned
            #   the same key will never overlap in time.
            run_key = f"run_key_{n_calls}"

            @bpp.run_decorator(md={})
            def plan(npts):

                for j in range(int(npts/2)):
                    yield from bps.mov(hw.motor1, j * 0.2)
                    yield from bps.trigger_and_read([hw.motor1, hw.det1])

                # Different parameter values may be passed to the recursively called plans
                yield from sim_plan_recursive(npts + 2)

                for j in range(int(npts/2), npts):
                    yield from bps.mov(hw.motor1, j * 0.2)
                    yield from bps.trigger_and_read([hw.motor1, hw.det1])

            yield from bpp.set_run_key_wrapper(plan(npts), run_key)
