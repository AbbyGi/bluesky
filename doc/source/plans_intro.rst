.. currentmodule:: bluesky.plans

Basic Usage & Intro to Plans
============================

Key Components
--------------

A *plan* is bluesky's concept of an experimental procedure, a sequence of
instructions to execute. Some common examples follow; many more are in a
:doc:`later section <plans>`. In Python jargon, a plan can be any iterable. It
could be a simple list or a generator, a concept which is addressed in detail
below.

Each granular instruction in a plan is dubbed a *message*. The :ref:`details of
the messages themselves <msg>` are not important for understanding what
follows.

The *RunEngine* is a kind of interpreter for plans. It executes the messages
in the plan, controlling hardware while monitoring for interruptions, collating
metadata and data, coordinating I/O, and ensuring that the hardware is left in
a safe state at exit time.

First Step: Creating a RunEngine
--------------------------------

This document is addressing three different audiences, and we have
different setup instructions for each.

*   If you are a user at NSLS-II taking real data, do nothing. You already
    have a RunEngine defined as the variable ``RE`` by your IPython profile,
    and it is configured to save data.

*   If you are a user at NSLS-II and you want to experiment with plans
    *without saving data*, start a new IPython session and define a clean
    RunEngine, which will not be configured to save data.

    .. code-block:: python

        from bluesky import RunEngine
        RE = RunEngine({})

    Close IPython when you are done, lest someone accidentally try to take
    real data with your "toy" RunEngine!

*   If you are a scientist and Python user casually exploring this library,
    just define a ``RunEngine`` instance and carry on:

    .. code-block:: python

        from bluesky import RunEngine
        RE = RunEngine({})


Executing Plans
---------------

Define a :func:`count` plan, which simply triggers and reads one or more
detectors, and pass it to the RunEngine for execution.

.. ipython:: python
    :suppress:

    from bluesky import RunEngine
    RE = RunEngine({})

.. ipython:: python

    from bluesky.plans import count
    from bluesky.examples import det  # a simulated detector
    RE(count([det]))

The return value is a unique identifier for the data set(s) generated by the
plan. To print something more useful to the screen, we'll send the data to
``LiveTable``, which formats the data generated by this plan into a table.

.. ipython:: python

    from bluesky.callbacks import LiveTable
    RE(count([det]), LiveTable([det]))

Bluesky provides more succinct ways to express this simple task --- read on!
--- but the above syntax shows all the pieces. The RunEngine ``RE`` consumes
the messages from the plan ``count([det])`` and sends the data to
``LiveTable([det])``, which then displays the time, sequence number, and
readings from ``det`` in real time.

.. note::

    Why ``[det]`` and not just ``det``? It is common to read a *list* of
    detectors as a group, like ``[det1, det2]``.

Introspecting Plans
-------------------

Separating the *specification* of the plan --- e.g., ``count([det])`` --- from
the *execution* of the plan --- ``RE(count([det]))`` --- lets us inspect
the plan before running it. It also let us modify a plan on the fly, as we'll
see :ref:`later below <preprocessors>`.

Bluesky provides a simple function for summarizing the action of a plan,
``print_summary``. Here, we see that the plan :func:`count` opens a "run" (i.e.,
dataset), takes a reading, and marks the end of that run.

.. ipython:: python

    from bluesky.plan_tools import print_summary
    from bluesky.examples import det
    from bluesky.plans import count
    print_summary(count([det]))

The plan :func:`scan` moves a motor in steps and takes a reading at each
position.

.. ipython:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, relative_scan
    print_summary(scan([det], motor, 1, 3, 3))

.. ipython:: python
   :suppress:

    motor.set(3)

As you might guess, :func:`relative_scan` moves the motor relative to its
starting position. And at the end, :func:`relative_scan` returns it to that
starting position.

.. ipython:: python

    print_summary(relative_scan([det], motor, 1, 3, 3))

Summarizing a plan is also a quick way to check for some types of errors.
More sophisticated error checking is possible and a likely area of future
development in bluesky.


.. note::

    As the name suggests, ``print_summary`` omits some details. To examine the
    full content of a plan, just pass it to ``list()``.
    
    This will not work on plans that are adaptive. Adaptive plans necessarily
    generate their messages on the fly.

Another useful application is visualization of plan trajectories. For example,
``plot_raster_path`` visualizes the trajectory of a two-motor system. The probe
size, given in "data space" units, provides a sense of this trajectory's
coverage of the sample.

.. note::

    In IPython, before running examples that generate plots, you may need to
    first run :ref:`some setup commands <kickers>`.

.. plot::
   :include-source:

    from bluesky.plan_tools import plot_raster_path
    from bluesky.examples import motor1, motor2, det
    from bluesky.plans import outer_product_scan
    import matplotlib.pyplot as plt

    plan = outer_product_scan([det], motor1, -5, 5, 10, motor2, -7, 7, 15, True)
    plot_raster_path(plan, 'motor1', 'motor2', probe_size=.3)

Combining Plans
---------------

To simply chain plans together, use :func:`pchain` to make one long plan.

.. code-block:: python

    from bluesky.examples import motor, det
    from bluesky.plans import scan, sleep, pchain

    RE(pchain(scan([det], motor, 1, 5, 3),
              sleep(1),
              scan([det], motor, 5, 10, 2)))

.. warning::

    Do not combine plans by calling the RunEngine more than once.

    .. code-block:: python

        # Don't do this.
        RE(plan1()); RE(plan2())

        # And also don't do this.
        def bad_idea():
            RE(plan1())
            RE(plan2())

    Calling ``RE(...)`` inside a function means that you can not use any of
    the introspection tools on the actions the function will take.
    
    Also, in the event of an error or interruptions, the RunEngine can do more
    to recover if it maintains control. In the bad example above, it loses
    control between completing ``plan1`` and beginning ``plan2``.

    Instead, use :func:`pchain` or ``yield from`` (see below) to make one long
    plan.

What if want to ``print`` or do other activities as part of a plan?
There is another way to combine plans to accommodate this:

.. code-block:: python

    def master_plan():
        "a plan that combines other plans, with interspersed code"

        # Scan and read detectors 1 and 2.
        yield from scan([det1, det2], motor, 1, 5, 10)

        print('Now plan1 is finished. Moving on to plan2.')

        # Scan again and just read detector 1.
        yield from relative_scan([det1], motor, 5, 10, 10)

    RE(master_plan())

The plan can employ control flow (``if`` blocks, ``for`` loops, etc.) and the
full power of the Python language. Many examples follow in the section on
:doc:`plans`.

An Aside on ``yield`` and ``yield from``
----------------------------------------

This is a very brief primer on the Python syntax ``yield`` and ``yield from``.

A Python *function* returns once:

.. ipython:: python

    def f():
        return 1

    f()

A Python *generator* is like a function with multiple exit points. Calling a
generator produces an *iterator* that yields one value at a time. After
each ``yield`` statement, its execution is suspended.

.. ipython:: python

    def f():
        yield 1
        yield 2

We can exhaust the generator (i.e., get all its values) by calling ``list()``.

.. ipython:: python

    list(f())

We can get one value at a time by calling ``next()``

.. ipython:: python

    it = f()
    next(it)
    next(it)

or by looping through the values.

.. ipython:: python

    for val in f():
        print(val)

To examine what is happening when, we can add prints.

.. ipython:: python

    def verbose_f():
        print("before 1")
        yield 1
        print("before 2")
        yield 2

.. ipython:: python

    it = verbose_f()
    next(it)
    next(it)

Notice that execution is suspended after the first yield statement. The
second ``print`` is not run until we resume execution by requesting a second
value. This is a useful feature of generators: they can express "lazy"
execution.

Generators can delegate to other generators using ``yield from``. This is
syntax we commonly use to combine plans.

.. ipython:: python

    def double_f():
        yield from f()
        yield from f()

.. ipython:: python

    list(double_f())
