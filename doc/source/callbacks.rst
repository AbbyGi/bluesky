Live Feedback
=============

.. ipython:: python
   :suppress:
   :okwarning:

   from bluesky.examples import det1, det2, det3, det, motor
   from bluesky.callbacks import *
   from bluesky import RunEngine, Msg
   RE = RunEngine()
   RE.verbose = False
   RE.md['owner'] = 'Jane'
   RE.md['group'] = 'Grant No. 12345'
   RE.md['config'] = {}
   RE.md['beamline_id'] = 'demo'
   from bluesky.scans import Count

Demo: live-updating table
-------------------------

As demonstrated in the :doc:`example workflow <workflow>`, a live-updating
table shows results as they come in.

.. ipython:: python
    :suppress:

    from bluesky.scans import Ascan
    dets = [det1, det2, det3]
    table = LiveTable(dets)
    RE.subscribe('all', table)  # Subscribe table to all future runs.
    s = Ascan(motor, dets, [1,2,4,8])

.. ipython:: python

    RE(s)

.. ipython:: python
    :suppress:

    RE.unsubscribe(0)

Demo: live-updating plot
------------------------

.. note::

    The live-plotting feature works, but by it's difficult to demo "live"
    thing on a static web page. Check back later!

Demo: live-updating image viewer
--------------------------------

.. note::

    The live image viewer works, but by it's difficult to demo "live"
    thing on a static web page. Check back later!


How this Works: Subscriptions
-----------------------------

What's a subscription?
++++++++++++++++++++++

As the RunEngine processes instructions, it creates *Documents,* plain Python
dictionaries organized in a
`specified but flexible <http://nsls-ii.github.io/arch/metadatastore-format.html>`__
way. These Documents contain
the data and metadata generated by the scan. Each time a new Document is
created, the RunEngine passes it to a list of functions. These functions can
do anyting: store the data to disk, transfer the data to a cluster,
update a plot, print a message, etc. The functions are called "callbacks." You
can think of them as a self-addressed stamped envelope. They tell the
RunEngine, "When you create a Document, send it to me for processing."

Two Very Simple Subscriptions
+++++++++++++++++++++++++++++

These simple examples illustrate the concept and the usage.

First, we define a function that takes a Python dictionary as its argument.
This is the "callback."

.. ipython:: python

    def print_data(doc):
        print("Measured: %s" % doc['data'])

Then, we tell the RunEngine to call this function on each Event Document.
We are setting up a subscription.

.. ipython:: python

    s = Count([det])
    RE(s, {'event': print_data})

Each time the RunEngine generates a new Event Doucment---which is, roughly
speaking, a datapoint---``print_data`` is called.

There are five kinds of subscriptions matching the four kinds of Documents plus
an 'all' subscription that receives all Documents.

* 'start'
* 'descriptor'
* 'event'
* 'stop'
* 'all'

We can use the 'stop' subscription to trigger automatic end-of-run activities.
For example:

.. ipython:: python

    def celebrate(doc):
        # Do nothing with the input; just use it as a signal that run is over.
        print("The run is finished!")

Let's use both ``print_data`` and ``celebrate`` at once.

.. ipython:: python

    RE(s, {'event': print_data, 'stop': celebrate})

Now With Less Typing!
+++++++++++++++++++++

To set up a subscription indefinitely for all future runs:

.. ipython:: python

    RE.subscribe('event', print_data)

This returns a token that we can use to unsubscribe later.

.. ipython:: python

    RE.unsubscribe(4)

Built-in Calbacks
-----------------

LiveTable
+++++++++

.. ipython:: python

    from bluesky.scans import Ascan
    scan = Ascan(motor, dets, [1,2,4,8])
    table = LiveTable(dets)

.. ipython:: python

    RE(scan, {'all': table})

All documents created by this scan are passed to LiveTable, which uses
them to print a table. As you can see, we specify the detectors---LiveTable
does not guess them---so we can focus on specific columns and avoid overly-wide
tables.

.. ipython:: python

    RE(scan, {'all': LiveTable(['det2'])})

To use a subscription by default, without typing it every time, subscribe it
to the RunEngine.

.. ipython:: python

    RE.subscribe('all', table)  # Subscribe table to all future runs.
    RE(scan)

The return value from ``subscribe`` is an integer token which we can use to
unsubscribe later.

.. ipython:: python

    RE.unsubscribe(7)

Live plot
+++++++++

.. note::

    In order to keep up with the scan, subscriptions skip over Documents
    when they fall behind. Be aware that plots may not show all points. (Don't
    worry: *all* the data is still being saved.)


Post-scan Export
++++++++++++++++

Post-scan Validation
++++++++++++++++++++

Writing your own
----------------

Any function that accepts a Python dictionary as its argument can be used as
a callback. Refer to simple examples above to get started.

Using multiple document types
+++++++++++++++++++++++++++++

Some tasks use only one Document type, but we often need to use more than one.
For example, LiveTable uses 'start' kick off the creation of a fresh table,
it uses 'event' to see the data, and it uses 'stop' to draw the bottom border.

A convenient pattern for this kind of subscription is a class with a method
for each Document type.

.. ipython:: python

    from bluesky.callbacks import CallbackBase
    class MyCallback(CallbackBase):
        def start(self, doc):
            print("I got a new 'start' Document")
            # Do something
        def descriptor(self, doc):
            print("I got a new 'descriptor' Document")
            # Do something
        def event(self, doc):
            print("I got a new 'event' Document")
            # Do something
        def stop(self, doc):
            print("I got a new 'stop' Document")
            # Do something


The base class, ``CallbackBase``, takes care of dispatching each Document to
the corresponding method. If your application does not need all four, you may
simple omit methods that aren't required.


Putting subscriptions into scans
--------------------------------

.. warning::

    This section requires some familiarity with Messages, covered in
    :doc:`custom-scans`. If you haven't at least skimmed that section of the
    documents, head over to that page and then revisit this.

To summarize, there are three ways to invoke a subscription. The first two were adressed
above.

1. Use a subscription for all future runs.
   
.. code-block:: python

    RE.subscribe(name, func)

2. Use a subscription for one run at a time.

.. code-block:: python
   
    RE(my_scan, {name: func})
    RE(my_scan, {name, [func1, func2]}  # P.S. A list of functions works, too.

3. Use subscriptions for every run of a given scan.

To demonstrate #3, we'll make a variant of the built-in ``Count`` scan that
prints a table using the ``LiveTable`` callback.

.. ipython:: python

    def count_with_table(detectors):
        table = LiveTable(detectors)
        # Here we cheat. LiveTable doesn't actually use the *contents* of the
        # Document from 'start', so we give it a fake one to cue setup.
        table.start({})
        yield Msg('subscribe', None, 'descriptor', table)
        yield Msg('subscribe', None, 'event', table)
        yield Msg('subscribe', None, 'stop', table)
        yield from Count(detectors)
    RE(count_with_table(dets))

One detail to notice is that callbacks subscribed inside the scan have
unreliable access to the 'start' Document: it might not still be there by the
time they start listening for it. To be safe (specifically, to avoid a race
condition) the RunEngine does not allow Messages to subscribe to 'start'.

Forunately, callbacks object just use 'start' to signal some setup code. For
like creating a new table. Here, we handle that setup manually. Likewise with
'stop'.

This slightly fancier invocation would makes the object returned by
``count_with_table`` reusble. (For context, see :ref:`reusable`.)

.. ipython:: python

    class CountWithTable(Count):
        # The superclass, Count, defines self.detectors and _gen,
        # which we use below.
        def _gen(self):
            table = LiveTable(self.detectors)
            yield Msg('subscribe', None, 'descriptor', table)
            yield Msg('subscribe', None, 'event', table)
            yield Msg('subscribe', None, 'stop', table)
            table.start({})
            yield from super()._gen()
    c = CountWithTable(dets)
    RE(c)

Critical Subscriptions
----------------------

Because subscriptions are processed during a scan, it's possible that they
can slow down data collection. We mitigate this by making the subscriptions
*lossy*. That is, some Documents will be skipped if the subscription
functions take too long and fall behind. For the purposes of real-time
feedback, this is usually acceptable. For other purposes, like saving data to
metadata store, it is not.

Critical subscriptions are subscriptions that block the scan thread,
potentially slowing down data collection but guaranteeing that all tasks
are completed but the scan proceeds.

For example, in the standard configuration, metadatastore insertion functions
are registered as critical subscriptions.

If your subscription requires the complete, lossless stream of Documents
and you are will to accept the possibility of slowing down data
collection while that stream in processed, you can register your own critical
subscriptions. Use ``RE._register_scan_callback(name, func)`` where ``name``
if one of ``'start'``, ``'descriptor'``, ``'event'``, ``'stop'``, and ``func``
is a callable that accepts a Python dictionary as its argument. Note that
there is no ``'all'`` callback implemented for critical subscriptions.
