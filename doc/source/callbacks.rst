Live Feedback
=============

.. ipython:: python
   :suppress:
   :okwarning:

   from bluesky.examples import det1, det2, det3, det, motor
   from bluesky.callbacks import *
   from bluesky import RunEngine
   RE = RunEngine()
   RE.verbose = False
   RE.md['owner'] = 'Jane'
   RE.md['group'] = 'Grant No. 12345'
   RE.md['config'] = {}
   RE.md['beamline_id'] = 'demo'
   from bluesky.scans import Count

Demo: live-updating table
-------------------------

As demonstrated in the :doc:`example workflow <workflow>`, a live-updating
table shows results as they come in.

.. ipython:: python
    :suppress:

    from bluesky.scans import Ascan
    table = LiveTable(['det1', 'det2', 'det3'])
    RE.subscribe('all', table)  # Subscribe table to all future runs.
    s = Ascan(motor, [det1, det2, det3], [1,2,4,8])

.. ipython:: python

    RE(s)

.. ipython:: python
    :suppress:

    RE.unsubscribe(0)

Demo: live-updating plot
------------------------

.. note::

    The live-plotting feature works, but by it's difficult to demo "live"
    thing on a static web page. Check back later!

Demo: live-updating image viewer
--------------------------------

.. note::

    The live image viewer works, but by it's difficult to demo "live"
    thing on a static web page. Check back later!


How this Works: Subscriptions
-----------------------------

What's a subscription?
++++++++++++++++++++++

As the RunEngine processes instructions, it creates *Documents,* plain Python
dictionaries organized in a
`specified but flexible <http://nsls-ii.github.io/arch/metadatastore-format.html>`__
way. These Documents contain
the data and metadata generated by the scan. Each time a new Document is
created, the RunEngine passes it to a list of functions. These functions can
do anyting: store the data to disk, transfer the data to a cluster,
update a plot, print a message, etc.

Two Very Simple Subscriptions
+++++++++++++++++++++++++++++

These simple examples illustrate the concept and the usage.

First, we define a function that takes a Python dictionary as its argument.

.. ipython:: python

    def print_data(doc):
        print("Measured: %s" % doc['data'])

Then, we tell the RunEngine to call this function on each Event Document.

.. ipython:: python

    s = Count([det])
    RE(s, {'event': print_data})

Each time the RunEngine generates a new Event Doucment---which is, roughly
speaking, a datapoint---``print_data`` is called.

There are five kinds of subscriptions matching the four kinds of Documents plus
an 'all' subscription that receives all Documents.

* 'start'
* 'descriptor'
* 'event'
* 'stop'
* 'all'

We can use the 'stop' subscription to trigger automatic end-of-run activities.
For example:

.. ipython:: python

    def celebrate(doc):
        # Do nothing with the input; just use it as a signal that run is over.
        print("The run is finished!")

Let's use both ``print_data`` and ``celebrate`` at once.

.. ipython:: python

    RE(s, {'event': print_data, 'stop': celebrate})

Now With Less Typing!
+++++++++++++++++++++

To invoke a subscription automatically for all future runs:

.. ipython:: python

    RE.subscribe('event', print_data)

This returns a token that we can use to unsubscribe later.

.. ipython:: python

    RE.unsubscribe(4)

Built-in Subscriptions
----------------------

LiveTable
+++++++++

.. ipython:: python

    from bluesky.scans import Ascan
    scan = Ascan(motor, [det1, det2, det3], [1,2,4,8])
    table = LiveTable(['det1', 'det2', 'det3'])

.. ipython:: python

    RE(scan, {'all': table})

All documents created by this scan are passed to LiveTable, which uses
them to print a table. As you can see, we specify the detectors---LiveTable
does not guess them---so we can focus on specific columns and avoid overly-wide
tables.

.. ipython:: python

    RE(scan, {'all': LiveTable(['det2'])})

To use a subscription by default, without typing it every time, subscribe it
to the RunEngine.

.. ipython:: python

    RE.subscribe('all', table)  # Subscribe table to all future runs.
    RE(scan)

The return value from ``subscribe`` is an integer token which we can use to
unsubscribe later.

.. ipython:: python

    RE.unsubscribe(2)

Live plot
+++++++++

.. note::

    In order to keep up with the scan, subscriptions skip over Documents
    when they fall behind. Be aware that plots may not show all points. (Don't
    worry: *all* the data is still being saved.)


Post-scan Export
++++++++++++++++

Post-scan Validation
++++++++++++++++++++

Writing your own
----------------

Examples
++++++++

TODO

Using multiple document types
+++++++++++++++++++++++++++++

Some tasks use only one Document type, but we often need to use more than one.
For example, LiveTable uses 'start' kick off the creation of a fresh table,
it uses 'event' to see the data, and it uses 'stop' to draw the bottom border.

A convenient pattern for this kind of subscription is a class with a method
for each Document type.

.. ipython:: python

    from bluesky.callbacks import CallbackBase
    class MyCallback(CallbackBase):
        def start(self, doc):
            # Do something

        def descriptor(self, doc):
            # Do something

        def event(self, doc):
            # Do something

        def stop(self, doc):
            # Do something


The base class, ``CallbackBase``, takes care of dispatching each Document to
the corresponding method.

Critical Subscriptions
----------------------

Because subscriptions are processed during a scan, it's possible that they
can slow down data collection. We mitigate this by making the subscriptions
*lossy*. That is, some Documents will be skipped if the subscription
functions take too long and fall behind. For the purposes of real-time
feedback, this is usually acceptable. For other purposes, like saving data to
metadata store, it is not.

Critical subscriptions are subscriptions that block the scan thread,
potentially slowing down data collection but guaranteeing that all tasks
are completed but the scan proceeds.

For example, in the standard configuration, metadatastore insertion functions
are registered as critical subscriptions.

If your subscription requires the complete, lossless stream of Documents
and you are will to accept the possibility of slowing down data
collection while that stream in processed, you can register your own critical
subscriptions. Use ``RE._register_scan_callback(name, func)`` where ``name``
if one of ``'start'``, ``'descriptor'``, ``'event'``, ``'stop'``, and ``func``
is a callable that accepts a Python dictionary as its argument. Note that
there is no ``'all'`` callback implemented for critical subscriptions.
