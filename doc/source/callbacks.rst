Live Feedback
=============

.. ipython:: python
   :okwarning:
   :suppress:

   from bluesky.examples import det1, det2, det3, det, motor
   from bluesky.callbacks import *
   from bluesky import RunEngine
   RE = RunEngine()
   RE.verbose = False
   RE.md['owner'] = 'Jane'
   RE.md['group'] = 'Grant No. 12345'
   RE.md['config'] = {}
   RE.md['beamline_id'] = 'demo'
   from bluesky.scans import Count

Demo: live-updating table
-------------------------

As demonstrated in the :doc:`example workflow <workflow>`, a live-updating
table shows results as they come in.

.. ipython:: python
    :suppress:

    from bluesky.scans import Ascan
    table = LiveTable(['det1', 'det2', 'det3'])
    RE.subscribe('all', table)  # Subscribe table to all future runs.
    s = Ascan(motor, [det1, det2, det3], [1,2,4,8])

.. ipython:: python

    RE(s)

.. ipython:: python
    :suppress:

    RE.unsubscribe(0)

Demo: live-updating plot
------------------------

.. ipython:: python
    :suppress:

    plot = LivePlot('det1')
    RE.subscribe('all', plot)

.. ipython:: python

    RE(s)

How this Works: Subscriptions
-----------------------------

What's a subscription?
++++++++++++++++++++++

As the RunEngine processes instructions, it creates *Documents,* plain Python
dictionaries organized in a
`specified but flexible <http://nsls-ii.github.io/arch/metadatastore-format.html>`__
way. These Documents contain
the data and metadata generated by the scan. Each time a new Document is
created, the RunEngine passes it to a list of functions. These functions can
do anyting: store the data to disk, transfer the data to a cluster,
update a plot, print a message, etc.

Two Very Simple Subscriptions
+++++++++++++++++++++++++++++

These simple examples illustrate the concept and the usage.

First, we define a function that takes a Python dictionary as its argument.

.. ipython:: python

    def print_data(doc):
        print("Measured: %s" % doc['data'])

Then, we tell the RunEngine to call this function on each Event Document.

.. ipython:: python

    s = Count([det])
    RE(s, {'event': print_data})

Each time the RunEngine generates a new Event Doucment---which is, roughly
speaking, a datapoint---``print_data`` is called.

There are five kinds of subscriptions matching the four kinds of Documents plus
an 'all' subscription that receives all Documents.

* 'start'
* 'descriptor'
* 'event'
* 'stop'
* 'all'

We can use the 'stop' subscription to trigger automatic end-of-run activities.
For example:

.. ipython:: python

    def celebrate(doc):
        # Do nothing with the input; just use it as a signal that run is over.
        print("The run is finished!")
    RE(s, {'event': print_data, 'stop': celebrate})


Bluesky includes a couple functions that make useful subscriptions.

In the standard_configuration, one critical subscription is configured at
startup time: a subscription that saves the Documents to metadatastore.

Other subscriptions are left up to the user, but if you find yourself using
one every time, you can add it to a start-up script or an IPython profile.

Built-in Subscriptions
----------------------

LiveTable Revisited
+++++++++++++++++++

As demonstrated in the :doc:`example workflow <workflow>`, a live-updating
table shows results as they come in.



.. ipython:: python

    from bluesky.scans import Ascan
    scan = Ascan(motor, [det1, det2, det3], [1,2,4,8])
    table = LiveTable(['det1', 'det2', 'det3'])

.. ipython:: python

    RE(scan, {'all': table})

All documents created by this scan are passed to LiveTable, which uses
them to print a table. As you can see, we specify the detectors---LiveTable
does not guess them---so we can focus on specific columns and avoid overly-wide
tables.

.. ipython:: python

    RE(scan, {'all': LiveTable(['det2'])})

To use a subscription by default, without typing it every time, subscribe it
to the RunEngine.

.. ipython:: python

    RE.subscribe('all', table)  # Subscribe table to all future runs.
    RE(scan)

The return value from ``subscribe`` is an integer token which we can use to
unsubscribe later.

.. ipython:: python

    RE.unsubscribe(2)

Live plot, Revisited
++++++++++++++++++++

.. note::

    In order to keep up with the scan, subscriptions skip over Documents
    when they fall behind. Be aware that plots may not show all points. (Don't
    worry: *all* the data is still being saved.)


Post-scan Export
++++++++++++++++

Post-scan Validation
++++++++++++++++++++

Writing your own
----------------

Simplest Example
++++++++++++++++

Using multiple document types
+++++++++++++++++++++++++++++

Critical Subscriptions
----------------------

Because subscriptions are processed during a scan, it's possible that they
can slow down data collection. We mitigate this by making the subscriptions
*lossy*. That is, some Documents will be skipped if the subscription
functions take too long and fall behind. For the purposes of real-time
feedback, this is usually acceptable. For other purposes, like saving data to
metadata store, it is not.

Critical subscriptions are subscriptions that block the scan thread,
potentially slowing down data collection but guaranteeing that all tasks
are completed but the scan proceeds.

For example, in the standard configuration, metadatastore insertion functions
are registered as critical subscriptions.

If your subscription requires the complete, lossless stream of Documents
and you are will to accept the possibility of slowing down data
collection while that stream in processed, you can register your own critical
subscriptions. Use ``RE._register_scan_callback(name, func)`` where ``name``
if one of ``'start'``, ``'descriptor'``, ``'event'``, ``'stop'``, and ``func``
is a callable that accepts a Python dictionary as its argument. Note that
there is no ``'all'`` callback implemented for critical subscriptions.
